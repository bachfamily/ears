#include "ears.commons.h"
#if defined EARS_MP3_WRITE_SUPPORT || defined EARS_MP3_READ_SUPPORT
#include "ears.mp3.h"
#endif

#ifdef EARS_WAVPACK_SUPPORT
#include "ears.wavpack.h"
#endif



t_buffer_obj *ears_buffer_make(t_symbol *buffername, bool add_to_ears_hashtable)
{
    if (buffername) {
        t_atom a;
        atom_setsym(&a, buffername);

#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Making buffer '%s'", buffername->s_name);
#endif

        if (add_to_ears_hashtable) {
            ears_hashtab_store(buffername);
            ears_hashtab_inccount(buffername);
        }
        
        return (t_buffer_obj *)object_new_typed(CLASS_BOX, gensym("buffer~"), 1, &a);
    } else {
#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Making auto-named buffer");
#endif

        return (t_buffer_obj *)object_new_typed(CLASS_BOX, gensym("buffer~"), 0, NULL);
    }
}



t_max_err ears_buffer_retain(t_buffer_obj *buffer, t_symbol *buffername, t_llll *generated_names)
{
    t_max_err err = MAX_ERR_NONE;
    
    if (generated_names && is_symbol_in_llll_first_level(generated_names, buffername)) {
        // this is an "old" buffer, already generated by the same object in dynamic mode
#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Recycling buffer '%s'", buffername->s_name);
#endif
    } else {
#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Retaining buffer '%s'", buffername->s_name);
#endif
        ears_hashtab_inccount(buffername);
        err = object_retain((t_object *)buffer);
    }
    return err;
}

t_max_err ears_buffer_release(t_buffer_obj *buffer, t_symbol *buffername)
{
    if (!buffer)
        return MAX_ERR_GENERIC;
    
    t_max_err err = MAX_ERR_NONE;

    err = object_free((t_object *)buffer);
    
    // now we handle the ears-only reference count
    t_atom_long count = 0;
    t_hashtab *ht = ears_hashtab_get();
    if (ht) {
        t_max_err err = hashtab_lookuplong(ht, buffername, &count);
        if (err == MAX_ERR_NONE) {
            if (count > 1) {
#ifdef EARS_ALLOCATIONVERBOSE
                    post("--- ears allocation: Releasing buffer '%s': now has ears-wide count %ld", buffername->s_name, count-1);
#endif
                hashtab_storelong(ht, buffername, count-1); // decrease reference count
            } else {
#ifdef EARS_ALLOCATIONVERBOSE
                    post("--- ears allocation: Releasing buffer '%s': ears-wide count is now 0. Spectral metadata will be removed.", buffername->s_name);
#endif
                hashtab_chuckkey(ht, buffername);

                // is this a spectral buffer? do we need to chuck it from the spectral hash table?
                t_object *meta = NULL;
                t_hashtab *htspec = ears_hashtab_spectrograms_get();
                if (hashtab_lookup(htspec, buffername, &meta) == MAX_ERR_NONE) {
                    if (meta) {
                        t_ears_spectralbuf_metadata *data = (t_ears_spectralbuf_metadata *)meta;
                        llll_free(data->bins);
                        data->bins = NULL;
                        hashtab_delete(htspec, buffername); // also frees memory
                    }
                }
            }
        }
    }
    
    return err;
}

// use it only for volatile temporary buffers that are created and then immediately destroyed
// otherwise use ears_buffer_release()
t_max_err ears_buffer_free(t_buffer_obj *buffer)
{
    t_symbol *buffername = ears_buffer_get_name(NULL, buffer);
    t_max_err err =  object_free((t_object *)buffer);

    t_hashtab *ht = ears_hashtab_get();
    t_atom_long count = 0;
    if (ht) {
        t_max_err err = hashtab_lookuplong(ht, buffername, &count);
        if (err == MAX_ERR_NONE) {
#ifdef EARS_ALLOCATIONVERBOSE
                post("--- ears allocation: Freeing buffer '%s': removing it from the hash table (it had count %ld)", buffername->s_name, count);
#endif
            hashtab_chuckkey(ht, buffername);
        }
    }
    
    return err;
}






t_object *ears_polybuffer_make(t_symbol *polybuffername, bool add_to_ears_hashtable)
{
    if (polybuffername) {
        t_atom a;
        atom_setsym(&a, polybuffername);

#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Making polybuffer '%s'", polybuffername->s_name);
#endif

        if (add_to_ears_hashtable) {
            ears_hashtab_store(polybuffername);
            ears_hashtab_inccount(polybuffername);
        }
        
        return (t_object *)object_new_typed(CLASS_BOX, gensym("polybuffer~"), 1, &a);
    } else {
#ifdef EARS_ALLOCATIONVERBOSE
            post("--- ears allocation: Making auto-named polybuffer");
#endif

        return (t_object *)object_new_typed(CLASS_BOX, gensym("polybuffer~"), 0, NULL);
    }
}


t_max_err ears_polybuffer_retain(t_buffer_obj *polybuffer, t_symbol *polybuffername)
{
    t_max_err err = MAX_ERR_NONE;

#ifdef EARS_ALLOCATIONVERBOSE
        post("--- ears allocation: Retaining polybuffer '%s'", polybuffername->s_name);
#endif
    ears_hashtab_inccount(polybuffername);
    err = object_retain((t_object *)polybuffer);
    return err;
}


t_max_err ears_polybuffer_release(t_buffer_obj *polybuffer, t_symbol *polybuffername)
{
    long polybuffer_count = object_attr_getlong(polybuffer, _sym_count);
    t_max_err err = MAX_ERR_NONE;
    
    err = object_free((t_object *)polybuffer);
    
    // now we handle the ears-only reference count
    t_atom_long count = 0;
    t_hashtab *ht = ears_hashtab_get();
    if (ht) {
        t_max_err err = hashtab_lookuplong(ht, polybuffername, &count);
        if (err == MAX_ERR_NONE) {
            if (count > 1) {
#ifdef EARS_ALLOCATIONVERBOSE
                    post("--- ears allocation: Releasing polybuffer '%s': now has ears-wide count %ld", polybuffername->s_name, count-1);
#endif
                hashtab_storelong(ht, polybuffername, count-1); // decrease reference count
            } else {
#ifdef EARS_ALLOCATIONVERBOSE
                    post("--- ears allocation: Releasing polybuffer '%s': ears-wide count is now 0.", polybuffername->s_name);
#endif
                hashtab_chuckkey(ht, polybuffername);
            }
        }
    }
    
    return err;
}




t_float *ears_buffer_locksamples(t_buffer_obj *buf)
{
    long l = buffer_getframecount(buf);
    if (l == 0) {
        // Max won't handle this case neatly. If we lock the buffer when it has NO samples, then unlock it, it will stay locked for some reason.
        return NULL;
    } else {
        return buffer_locksamples(buf);
    }
}

void ears_buffer_unlocksamples(t_buffer_obj *buf)
{
    long l = buffer_getframecount(buf);
    if (l == 0) {
        // Max won't handle this case neatly. If we lock the buffer when it has NO samples, then unlock it, it will stay locked for some reason.
    } else {
        buffer_unlocksamples(buf);
    }
}







t_atom_long ears_buffer_get_size_samps(t_object *ob, t_buffer_obj *buf, bool use_original_audio_sr_for_spectral_buffers)
{
    if (use_original_audio_sr_for_spectral_buffers && ears_buffer_is_spectral(ob, buf)) {
        // TODO: check
        double hopsize_samps = ears_spectralbuf_get_original_audio_sr(ob, buf) * 1./ears_buffer_get_sr(ob, buf);
        return buffer_getframecount(buf) * hopsize_samps;
    }

    return buffer_getframecount(buf);
}


double ears_buffer_get_size_ms(t_object *ob, t_buffer_obj *buf)
{
    return ears_samps_to_ms(buffer_getframecount(buf), buffer_getsamplerate(buf));
}


t_atom_float ears_buffer_get_sr(t_object *ob, t_buffer_obj *buf, bool use_original_audio_sr_for_spectral_buffers)
{
    if (!buf) {
        object_bug(ob, "Trying to compute sample rate of NULL buffer.");
        return ears_get_current_Max_sr();
    }
    if (use_original_audio_sr_for_spectral_buffers && ears_buffer_is_spectral(ob, buf))
        return ears_spectralbuf_get_original_audio_sr(ob, buf);
    
    return buffer_getsamplerate(buf);
}

t_atom_long ears_buffer_get_numchannels(t_object *ob, t_buffer_obj *buf)
{
    return buffer_getchannelcount(buf);
/*    t_buffer_info info;
    buffer_getinfo(buf, &info);
    return info.b_nchans;
 */
}

t_symbol *ears_buffer_get_sampleformat(t_object *ob, t_buffer_obj *buf)
{
    return object_attr_getsym(buf, gensym("format"));
}

t_ears_err ears_buffer_set_sampleformat(t_object *ob, t_buffer_obj *buf, t_symbol *sampleformat)
{
    object_attr_setsym(buf, gensym("format"), sampleformat);
    return EARS_ERR_NONE;
}



void ears_buffer_set_size_samps_do(t_object *ob, t_symbol *s, long ac, t_atom *av)
{
    t_buffer_obj *buf = (t_buffer_obj *)atom_getobj(av+1);
    typedmess(buf, gensym("sizeinsamps"), 1, av);
    ((t_earsbufobj *)ob)->l_buffer_size_changed = 1;
}


t_ears_err ears_buffer_set_size_samps(t_object *ob, t_buffer_obj *buf, long num_frames)
{
    if (num_frames == 0) {
//        object_warn(ob, "Warning: buffer is resized at zero size!");
    }
    
    t_atom a[2];
    atom_setlong(a, num_frames);
    atom_setobj(a+1, buf);
    
    if (num_frames != ears_buffer_get_size_samps(ob, buf)) {
        if (((t_earsbufobj *)ob)->l_blocking == 1) {
            typedmess(buf, gensym("sizeinsamps"), 1, a);
        } else {
            if (buffer_getframecount(buf) != num_frames) {
                ((t_earsbufobj *)ob)->l_buffer_size_changed = 0;
                defer(ob, (method)ears_buffer_set_size_samps_do, NULL, 2, a);
                while (!((t_earsbufobj *)ob)->l_buffer_size_changed) {
//                    post("waiting");
                }
            }
        }
    }
    return EARS_ERR_NONE;
}


t_ears_err ears_buffer_set_size_samps_preserve(t_object *ob, t_buffer_obj *buf, long num_frames)
{
    if (num_frames == 0) {
//        object_warn(ob, "Warning: buffer is resized at zero size!");
    }

    long curr_num_frames = ears_buffer_get_size_samps(ob, buf);
    if (num_frames < curr_num_frames) {
        ears_buffer_crop_inplace(ob, buf, 0, num_frames);
    } else if (num_frames > curr_num_frames) {
        t_atom_long channelcount = ears_buffer_get_numchannels(ob, buf);
        float *temp = (float *)bach_newptr(curr_num_frames * channelcount * sizeof(float));
        float *sample = ears_buffer_locksamples(buf);
        sysmem_copyptr(sample, temp, curr_num_frames * channelcount * sizeof(float));
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_size_samps(ob, buf, num_frames);
        sample = ears_buffer_locksamples(buf);
        sysmem_copyptr(temp, sample, curr_num_frames * channelcount * sizeof(float));
        ears_buffer_unlocksamples(buf);
        bach_freeptr(temp);
    }
    return EARS_ERR_NONE;
}


void ears_buffer_set_size_and_numchannels_do(t_object *ob, t_symbol *s, long ac, t_atom *av)
{
    t_buffer_obj *buf = (t_buffer_obj *)atom_getobj(av+2);
    typedmess(buf, gensym("sizeinsamps"), 2, av);
    ((t_earsbufobj *)ob)->l_buffer_size_changed = 1;
}


// ONE NEEDS TO MAKE SURE that this function is called when the samples of buf ARE NOT LOCKED!!!!
t_ears_err ears_buffer_set_size_and_numchannels(t_object *ob, t_buffer_obj *buf, long num_frames, long numchannels)
{
    if (num_frames == 0 || numchannels == 0) {
//        object_warn(ob, "Warning: buffer is resized at zero size!");
    }
    t_atom a[3];
    atom_setlong(a, num_frames);
    atom_setlong(a+1, numchannels);
    atom_setobj(a+2, buf);
    if (((t_earsbufobj *)ob)->l_blocking == 1) {
        typedmess(buf, gensym("sizeinsamps"), 2, a);
    } else {
        if (buffer_getframecount(buf) != num_frames || buffer_getchannelcount(buf) != numchannels) {
            ((t_earsbufobj *)ob)->l_buffer_size_changed = 0;
            defer(ob, (method)ears_buffer_set_size_and_numchannels_do, NULL, 3, a);
            while (!((t_earsbufobj *)ob)->l_buffer_size_changed) {
                cpost("ears is waiting for the main thread to resize a buffer...");
            }
        }
    }
    return EARS_ERR_NONE;
}

t_ears_err ears_buffer_set_numchannels(t_object *ob, t_buffer_obj *buf, long numchannels)
{
    return ears_buffer_set_size_and_numchannels(ob, buf, ears_buffer_get_size_samps(ob, buf), numchannels);
}





t_ears_err ears_buffer_set_sr(t_object *ob, t_buffer_obj *buf, double sr)
{
    t_atom a;
    atom_setfloat(&a, sr);
    typedmess(buf, gensym("sr"), 1, &a);
    return EARS_ERR_NONE;
}

t_ears_err ears_buffer_clear(t_object *ob, t_buffer_obj *buf)
{
    typedmess(buf, gensym("clear"), 0, NULL);
    return EARS_ERR_NONE;
}

t_symbol *ears_buffer_get_name(t_object *ob, t_buffer_obj *buf)
{
    t_buffer_info info;
    info.b_name = NULL;
    if (!buf) {
        object_bug(ob, "Trying to get name of NULL buffer.");
        return NULL;
    }
    buffer_getinfo(buf, &info);
    return info.b_name;
}




bool ears_buffers_have_the_same_sr(t_object *ob, long num_buffers, t_buffer_obj **buffer)
{
    if (num_buffers <= 1)
        return true;
    
    double sr = -1;
    for (long i = 0; i < num_buffers; i++) {
        if (!buffer[i])
            continue;
        double this_sr = ears_buffer_get_sr(ob, buffer[i]);
        if (sr < 0) sr = this_sr;
        if (this_sr != sr)
            return false;
    }
    return true;
}

double ears_buffers_get_lowest_sr(t_object *ob, long num_buffers, t_buffer_obj **buffer)
{
    if (num_buffers < 1)
        return 0;
    
    double sr = DBL_MAX;
    for (long i = 0; i < num_buffers; i++) {
        if (!buffer[i])
            continue;
        double this_sr = ears_buffer_get_sr(ob, buffer[i]);
        if (this_sr < sr)
            sr = this_sr;
    }
    return sr == DBL_MAX ? 0 : sr;
}

double ears_buffers_get_highest_sr(t_object *ob, long num_buffers, t_buffer_obj **buffer)
{
    if (num_buffers < 1)
        return 0;
    
    double sr = DBL_MIN;
    for (long i = 0; i < num_buffers; i++) {
        if (!buffer[i])
            continue;
        double this_sr = ears_buffer_get_sr(ob, buffer[i]);
        if (this_sr > sr)
            sr = this_sr;
    }
    return sr == DBL_MIN ? 0 : sr;
}

bool is_in_vec_double(double num, std::vector<double> &vec)
{
    for (long i = 0; i < vec.size(); i++)
        if (num == vec[i])
            return true;
    return false;
}

double ears_buffers_get_mostcommon_sr(t_object *ob, long num_buffers, t_buffer_obj **buffer)
{
    if (num_buffers < 1)
        return 0;
    
    double most_common_sr = 0;
    long most_common_count = 0;
    std::vector<double> processed_sr;
    for (long i = 0; i < num_buffers; i++) {
        if (!buffer[i])
            continue;
        
        double this_sr = ears_buffer_get_sr(ob, buffer[i]);
        if (is_in_vec_double(this_sr, processed_sr))
            continue;
        processed_sr.push_back(this_sr);
        long count = 1;
        for (long j = i+1; j < num_buffers; j++) {
            if (!buffer[j])
                continue;
            if (ears_buffer_get_sr(ob, buffer[j]) == this_sr)
                count++;
        }
        if (count > most_common_count) {
            most_common_sr = this_sr;
            most_common_count = count;
        }
    }
    return most_common_sr;
}


double ears_buffers_get_collective_sr(t_object *ob, long numbuffers, t_buffer_obj **buffer, e_ears_resamplingpolicy resamplingpolicy)
{
    switch (resamplingpolicy) {
        case EARS_RESAMPLINGPOLICY_TOLOWESTSR:
            return ears_buffers_get_lowest_sr(ob, numbuffers, buffer);
            break;
            
        case EARS_RESAMPLINGPOLICY_TOHIGHESTSR:
            return ears_buffers_get_highest_sr(ob, numbuffers, buffer);
            break;

        case EARS_RESAMPLINGPOLICY_TOMOSTCOMMONSR:
            return ears_buffers_get_mostcommon_sr(ob, numbuffers, buffer);
            break;

        case EARS_RESAMPLINGPOLICY_TOCURRENTMAXSR:
            return sys_getsr();
            break;
            
        default:
            return 0;
            break;
    }
}


// THESE 3 ARE TOO DANGEROUS
/*
long get_hidden_sr_offset()
{
    return (sizeof(t_object) + 9*sizeof(long) + 3*sizeof(float)+ 2*sizeof(float*) + sizeof(t_symbol*)+2*sizeof(short)+sizeof(void*) + 2 * sizeof(double) + 7*sizeof(short))/sizeof(short);
}

t_ears_err ears_buffer_set_hidden_sr(t_object *ob, t_buffer_obj *buf, double sr)
{
    long offset = get_hidden_sr_offset();

    unsigned int sr_int = sr;
    unsigned short s1 = sr_int % (1 << 16);
    unsigned short s2 = sr_int >> 16;
    
    *(((unsigned short *)buf)+offset) = (unsigned short)s1;
    *(((unsigned short *)buf)+offset+1) = (unsigned short)s2;
    return EARS_ERR_NONE;
}


t_atom_float ears_buffer_get_hidden_sr(t_object *ob, t_buffer_obj *buf)
{
    long offset = get_hidden_sr_offset();
    unsigned short s1 = *(((unsigned short *)buf)+offset);
    unsigned short s2 = *(((unsigned short *)buf)+offset+1);

    return (s2 << 16) + s1;
}
*/


// THESE ONES ARE BETTER

// turns a spectralbuf into an ordinary buffer
t_ears_err ears_spectralbuf_metadata_remove(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    if (data) {
        llll_free(data->bins);
        data->bins = NULL;
        if (hashtab_delete(ears_hashtab_spectrograms_get(), ears_buffer_get_name(ob, buf)) == MAX_ERR_NONE)
            return EARS_ERR_NONE;
    }
    return EARS_ERR_GENERIC;
}

t_ears_err ears_spectralbuf_metadata_set(t_object *ob, t_buffer_obj *buf, t_ears_spectralbuf_metadata *data)
{
    t_symbol *buffer_name = ears_buffer_get_name(ob, buf);
    if (buffer_name) {
        t_ears_spectralbuf_metadata *storeddata = (t_ears_spectralbuf_metadata *)sysmem_newptrclear(sizeof(t_ears_spectralbuf_metadata));
        storeddata->original_audio_signal_sr = data->original_audio_signal_sr;
        storeddata->binsize = data->binsize;
        storeddata->binoffset = data->binoffset;
        storeddata->binunit = data->binunit;
        storeddata->type = data->type;
        llll_free(storeddata->bins);
        storeddata->bins = data->bins ? llll_clone(data->bins) : NULL;
        if (ears_hashtab_spectrograms_store(buffer_name, storeddata) == 0) {
            ears_buffer_set_sampleformat(ob, buf, _sym_float32); // also sets sample format as float32
            return EARS_ERR_NONE;
        }
        return EARS_ERR_GENERIC;
    }
    
    return EARS_ERR_GENERIC;
}

bool ears_buffer_is_spectral(t_object *ob, t_buffer_obj *buf)
{
    if (ears_spectralbuf_metadata_get(ob, buf) == NULL)
        return false;
    return true;
}

// When you use this function, you should NOT FREE the obtained metadata, you don't own them
t_ears_spectralbuf_metadata *ears_spectralbuf_metadata_get(t_object *ob, t_buffer_obj *buf)
{
    t_symbol *buffer_name = ears_buffer_get_name(ob, buf);
    return (t_ears_spectralbuf_metadata *)ears_hashtab_spectrograms_retrieve(buffer_name);
}

double ears_spectralbuf_get_original_audio_sr(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    return data ? data->original_audio_signal_sr : ears_buffer_get_sr(ob, buf);
}


double ears_spectralbuf_get_binsize(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    return data ? data->binsize : 0;
}


double ears_spectralbuf_get_binoffset(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    return data ? data->binoffset : 0;
}


t_symbol *ears_spectralbuf_get_spectype(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    return data ? data->type : _llllobj_sym_none;
}

e_ears_frequnit ears_spectralbuf_get_binunit(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    return data ? data->binunit : EARS_FREQUNIT_UNKNOWN;
}

t_llll* ears_spectralbuf_get_bins(t_object *ob, t_buffer_obj *buf)
{
    t_ears_spectralbuf_metadata *data = ears_spectralbuf_metadata_get(ob, buf);
    if (data)
        return data->bins;
    else
        return NULL;
}


t_ears_err ears_buffer_crop_ms_inplace_maxapi(t_object *ob, t_buffer_obj *buf, double ms_start, long ms_end)
{
    // Using MAX Api, This is not so flexible, because it is quirky when ms_end is > buffer size, and also it doesn't deal with partial cropping (only start or end defined)
    t_atom a[2];
    atom_setfloat(a, ms_start);
    atom_setfloat(a+1, ms_end);
    typedmess(buf, gensym("crop"), 2, a);
    return EARS_ERR_NONE;
}


t_ears_err ears_buffer_normalize_inplace(t_object *ob, t_buffer_obj *buf, double level)
{
    t_atom a;
    atom_setfloat(&a, level);
    typedmess(buf, gensym("normalize"), 1, &a);
    return EARS_ERR_NONE;
}





t_ears_err ears_buffer_copy_format_and_set_size_samps(t_object *ob, t_buffer_obj *orig, t_buffer_obj *dest, long num_frames)
{
    if (!orig || !dest) {
        object_error((t_object *)ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    t_atom_long    orig_channelcount = buffer_getchannelcount(orig);        // number of floats in a frame
    double orig_sr = buffer_getsamplerate(orig);          // sample rate of the buffer in samples per second

    t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
    t_atom_long    dest_num_frames = buffer_getframecount(dest);
    double dest_sr = buffer_getsamplerate(dest);
    
    if (dest_sr != orig_sr)
        ears_buffer_set_sr(ob, dest, orig_sr);
    if (dest_channelcount != orig_channelcount || num_frames != dest_num_frames) {
        ears_buffer_set_size_and_numchannels(ob, dest, num_frames, orig_channelcount);
    }
    
    // is spectral?
    if (ears_buffer_is_spectral(ob, orig)) {
        ears_spectralbuf_metadata_set(ob, dest, ears_spectralbuf_metadata_get(ob, orig));
    } else {
        if (ears_spectralbuf_metadata_get(ob, dest))
            ears_spectralbuf_metadata_remove(ob, dest);
    }
    
//    dest_channelcount = buffer_getchannelcount(dest);
//    dest_sr = buffer_getsamplerate(dest);

    return EARS_ERR_NONE;
}


t_ears_err ears_buffer_copy_format(t_object *ob, t_buffer_obj *orig, t_buffer_obj *dest, bool dont_change_buffer_size)
{
    if (!orig || !dest) {
        object_error((t_object *)ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    t_atom_long	orig_channelcount = buffer_getchannelcount(orig);		// number of floats in a frame
    double orig_sr = buffer_getsamplerate(orig);          // sample rate of the buffer in samples per second

    t_atom_long	dest_channelcount = buffer_getchannelcount(dest);	
    double dest_sr = buffer_getsamplerate(dest);

    if (dest_sr != orig_sr)
        ears_buffer_set_sr(ob, dest, orig_sr);
    
    if (!dont_change_buffer_size) {
        if (dest_channelcount != orig_channelcount)
            ears_buffer_set_numchannels(ob, dest, orig_channelcount);
    }
    
    // is spectral?
    if (ears_buffer_is_spectral(ob, orig)) {
        ears_spectralbuf_metadata_set(ob, dest, ears_spectralbuf_metadata_get(ob, orig));
    } else {
        if (ears_spectralbuf_metadata_get(ob, dest))
            ears_spectralbuf_metadata_remove(ob, dest);
    }
    
//    dest_channelcount = buffer_getchannelcount(dest);
//    dest_sr = buffer_getsamplerate(dest);

    return EARS_ERR_NONE;
}



// reverse buffer
t_ears_err ears_buffer_rev_inplace(t_object *ob, t_buffer_obj *buf)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        if (framecount > 0) {
            float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
            
            
            for (long i = 0; i < framecount; i++)
                for (long c = 0; c < channelcount; c++)
                    sample[i*channelcount + c] = temp[(framecount - i - 1)*channelcount + c];
            
            bach_freeptr(temp);
            buffer_setdirty(buf);
        }
        
        ears_buffer_unlocksamples(buf);
    }
    return err;
}



// rotate buffer
t_ears_err ears_buffer_rot_inplace(t_object *ob, t_buffer_obj *buf, long shift_in_samps)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        shift_in_samps = positive_mod(shift_in_samps, framecount);
        
        if (framecount > 0) {
            float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
            
            sysmem_copyptr(temp+shift_in_samps*channelcount, sample, channelcount * (framecount - shift_in_samps) * sizeof(float));
            sysmem_copyptr(temp, sample + channelcount * (framecount - shift_in_samps), channelcount * shift_in_samps * sizeof(float));

            bach_freeptr(temp);
            buffer_setdirty(buf);
        }
        
        ears_buffer_unlocksamples(buf);
    }
    return err;
}



// fill buffer with single value
t_ears_err ears_buffer_fill_inplace(t_object *ob, t_buffer_obj *buf, float val)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        if (framecount > 0) {
            for (long i = 0; i < framecount; i++)
                for (long c = 0; c < channelcount; c++)
                    sample[i*channelcount + c] = val;
            
            buffer_setdirty(buf);
        }
        
        ears_buffer_unlocksamples(buf);
    }
    return err;
}



// fill buffer with random range
t_ears_err ears_buffer_random_fill_inplace(t_object *ob, t_buffer_obj *buf, double v_min, double v_max)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        if (framecount > 0) {
            for (long i = 0; i < framecount; i++)
                for (long c = 0; c < channelcount; c++)
                    sample[i*channelcount + c] = random_double_in_range(v_min, v_max);
            
            buffer_setdirty(buf);
        }
        
        ears_buffer_unlocksamples(buf);
    }
    return err;
}

// reverse channels in a buffer
t_ears_err ears_buffer_rev_channels_inplace(t_object *ob, t_buffer_obj *buf)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        if (framecount > 0) {
            float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
            
            
            for (long i = 0; i < framecount; i++)
                for (long c = 0; c < channelcount; c++)
                    sample[i*channelcount + c] = temp[i*channelcount + (channelcount - c - 1)];
            
            bach_freeptr(temp);
            buffer_setdirty(buf);
        }
        
        ears_buffer_unlocksamples(buf);
    }
    return err;
}


// fill buffer with random range
t_ears_err ears_buffer_apply_mask(t_object *ob, t_buffer_obj *buf1, t_buffer_obj *buf2, t_buffer_obj *mask)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample1 = ears_buffer_locksamples(buf1);
    float *sample2 = ears_buffer_locksamples(buf2);
    float *sampleM = ears_buffer_locksamples(mask);

    if (!sample1 || !sample2 || !sampleM) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount1 = buffer_getchannelcount(buf1);
        t_atom_long    framecount1   = buffer_getframecount(buf1);
        t_atom_long    channelcount2 = buffer_getchannelcount(buf2);
        t_atom_long    framecount2   = buffer_getframecount(buf2);
        t_atom_long    channelcountM = buffer_getchannelcount(mask);
        t_atom_long    framecountM   = buffer_getframecount(mask);

        if (channelcount1 == channelcount2 && channelcount2 == channelcountM &&
            framecount1 == framecount2 && framecount2 == framecountM) {
            
            for (long i = 0; i < framecount1; i++)
                for (long c = 0; c < channelcount1; c++)
                    if (sampleM[i*channelcount1 + c] != 0)
                        sample1[i*channelcount1 + c] = sample2[i*channelcount1 + c];
            
            buffer_setdirty(buf1);
        } else {
            object_error(ob, "Size mismatch in spectral buffers.");
            err = EARS_ERR_GENERIC;
        }
        
        ears_buffer_unlocksamples(buf1);
        ears_buffer_unlocksamples(buf2);
        ears_buffer_unlocksamples(mask);
    }
    return err;
}






double ears_interp_circular_sinc(float *in, long num_in_frames, double index, double window_width)
{
    long i, j;
    double r_w, r_a, r_snc;
    double r_g = 1;
    double r_y = 0;
    for (i = -window_width/2; i <= window_width/2; i++) { // For 1 window width
        j = (long)(index + i);          // Calc input sample index
        //rem calculate von Hann Window. Scale and calculate Sinc
        r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (j - index)/window_width));
        r_a     = TWOPI*(j - index)*0.5;
        r_snc   = (r_a != 0 ? sin(r_a)/r_a : 1); ///<< sin(r_a) is slow. Do we have other options?
        j = positive_mod(j, num_in_frames);
        r_y   = r_y + r_g * r_w * r_snc * in[j];
    }
    return r_y;                  // Return new filtered sample
}

// band limited interpolation
double ears_interp_sinc(float *in, long num_in_frames, double index, double window_width, long step)
{
    long i, j;
    double r_w, r_a, r_snc;
    double r_g = 1;
    double r_y = 0;
    long index_floor = floor(index);
    double diff = index-index_floor;
    for (i = -window_width/2; i <= window_width/2; i++) { // For 1 window width
//        j = (long)floor(index + i);          // Calc input sample index
        j = index_floor + i;
        if (j >= 0 && j < num_in_frames) {
            //rem calculate von Hann Window. Scale and calculate Sinc
//            r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (j - index)/window_width));
//            r_a     = TWOPI*(j - index)*0.5;
            r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (i - diff)/window_width));
            r_a     = TWOPI*(i - diff)*0.5;
            r_snc   = (r_a != 0 ? sin(r_a)/r_a : 1); ///<< sin(r_a) is slow. Do we have other options?
            r_y   = r_y + r_g * r_w * r_snc * in[j*step];
        }
    }
    return r_y;                  // Return new filtered sample
}



// Could be improved
// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_sinc(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels, double fmax, double sr, double window_width)
{
    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        for (long s = 0; s < num_out_frames; s++) {
            long i, j;
            double x = s / factor;
            double r_w, r_a, r_snc;
            double r_g = 2 * fmax / sr; // Calc gain correction factor
            double r_y = 0;
            for (i = -window_width/2; i <= window_width/2; i++) { // For 1 window width // Was: i < window_width/2.
                j = (long)(x + i);          // Calc input sample index
                //rem calculate von Hann Window. Scale and calculate Sinc
                r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (j - x)/window_width));
                r_a     = TWOPI*(j - x)*fmax/sr;
                r_snc   = (r_a != 0 ? sin(r_a)/r_a : 1); ///<< sin(r_a) is slow. Do we have other options?
                if (j >= 0 && j < num_in_frames)
                    r_y   = r_y + r_g * r_w * r_snc * in[num_channels * j + ch];
            }
            (*out)[num_channels * s + ch] = r_y;                  // Return new filtered sample
        }
    }
    return num_out_frames * num_channels;
}

// EXPERIMENTAL, single channel for now
// beware: <in> should be allocated with num_in_frames * num_channels floats
long ears_resample_sinc_env_speed_circular(float *in, long num_in_frames, float **out, double start_factor, double end_factor, double factor_factor, long num_channels, double orig_sr, double window_width, long maxlen_samps)
{
    long actual_num_out_frames = 0;
    for (long ch = 0; ch < 1 /*num_channels*/; ch++) {
        long alloc = EARS_BUFFER_ASSEMBLE_ALLOCATION_STEP_SEC * orig_sr * num_channels;
        *out = (float *)bach_newptr(alloc * sizeof(float));
        
        double factor = start_factor;
        bool rall = (end_factor >= start_factor);
        double x = 0;
        long s = 0;
        double sr = orig_sr * factor;
        while (((rall && factor < end_factor) || (!rall && factor > end_factor)) && (maxlen_samps <= 0 || s < maxlen_samps)) {
            long i, j;
            double r_w, r_a, r_snc;
            double fmax = sr / 2.; // TO DO
            double r_g = 2 * fmax / sr; // Calc gain correction factor
            double r_y = 0;
            for (i = -window_width/2; i < window_width/2; i++) { // For 1 window width
//                x = s / factor;
                j = (long)(x + i);          // Calc input sample index
                //rem calculate von Hann Window. Scale and calculate Sinc
                r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (j - x)/window_width));
                r_a     = TWOPI*(j - x)*fmax/sr;
                r_snc   = (r_a != 0 ? r_snc = sin(r_a)/r_a : 1); ///<< sin(r_a) is slow. Do we have other options?
                j = positive_mod(j, num_in_frames);
//                if (j >= 0 && j < num_in_frames)
                r_y   = r_y + r_g * r_w * r_snc * in[num_channels * j + ch];
            }

            long t = num_channels * s + ch;
            if (t >= alloc) {
                alloc += EARS_BUFFER_ASSEMBLE_ALLOCATION_STEP_SEC * orig_sr * num_channels;
                *out = (float *)bach_resizeptr(*out, alloc * sizeof(float));
            }
            (*out)[num_channels * s + ch] = r_y;                  // Return new filtered sample
            x += 1 / factor;
            s++;
            factor *= factor_factor;
            sr = orig_sr * factor;
        }
        actual_num_out_frames = s;
    }
    return actual_num_out_frames * num_channels;
}


// Could be improved
// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_sinc_env(float *in, long num_in_frames, float **out, long num_out_frames, t_ears_envelope_iterator *factor_env, long num_channels, double fmax, double sr, double window_width)
{
    double maxfactor = ears_envelope_iterator_get_max_y(factor_env);
    long actual_num_out_frames = num_out_frames;
    if (num_out_frames <= 0) // num_out_frames is an estimate in any case
        num_out_frames = (long)ceil(num_in_frames * maxfactor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        ears_envelope_iterator_reset(factor_env);
        
        long pivot_sample = 0;
        double factor = ears_envelope_iterator_walk_interp(factor_env, pivot_sample, num_in_frames);
        double x = 0;
        for (long s = 0; s < num_out_frames; s++) {
            long i, j;
            double r_w, r_a, r_snc;
            double r_g = 2 * fmax / sr; // Calc gain correction factor
            double r_y = 0;
            if (x - window_width/2 > num_in_frames) {
                actual_num_out_frames = s;
                break;
            }
            for (i = -window_width/2; i < window_width/2; i++) { // For 1 window width
//                x = s / factor;
                j = (long)(x + i);          // Calc input sample index
                //rem calculate von Hann Window. Scale and calculate Sinc
                r_w     = 0.5 - 0.5 * cos(TWOPI*(0.5 + (j - x)/window_width));
                r_a     = TWOPI*(j - x)*fmax/sr;
                r_snc   = (r_a != 0 ? r_snc = sin(r_a)/r_a : 1); ///<< sin(r_a) is slow. Do we have other options?
                if (j >= 0 && j < num_in_frames)
                    r_y   = r_y + r_g * r_w * r_snc * in[num_channels * j + ch];
            }
            (*out)[num_channels * s + ch] = r_y;                  // Return new filtered sample
            x += 1 / factor;
            if ((long)x > pivot_sample) {
                factor = ears_envelope_iterator_walk_interp(factor_env, (long)x, num_in_frames);
                pivot_sample = (long)x;
            }
        }
    }
    return actual_num_out_frames * num_channels;
}


// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_sampleandhold(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels)
{
    if (num_in_frames < 1) {
        // single value
        for (long ch = 0; ch < num_channels; ch++) {
            for (long s = 0; s < num_out_frames; s++) {
                (*out)[num_channels * s + ch] = 0;
            }
        }
        return num_out_frames * num_channels;
    }

    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        for (long s = 0; s < num_out_frames; s++) {
            double x = s / factor;
            long j = CLAMP((long)x, 0, num_in_frames-1); // floor
            (*out)[num_channels * s + ch] = in[num_channels * j + ch];
        }
    }
    return num_out_frames * num_channels;
}


// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_nearestneighbor(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels)
{
    if (num_in_frames < 2)
        return ears_resample_sampleandhold(in, num_in_frames, out, num_out_frames, factor, num_channels);

    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        for (long s = 0; s < num_out_frames; s++) {
            double x = s / factor;
            long j = CLAMP((long)(round(x)), 0, num_in_frames-1); // round
            (*out)[num_channels * s + ch] = in[num_channels * j + ch];
        }
    }
    return num_out_frames * num_channels;
}



// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_linear(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels)
{
    if (num_in_frames < 2)
        return ears_resample_sampleandhold(in, num_in_frames, out, num_out_frames, factor, num_channels);

    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        for (long s = 0; s < num_out_frames; s++) {
            double x = s / factor;
            long j = CLAMP((long)x, 0, num_in_frames-2); // floor
            double t = x - j;
            (*out)[num_channels * s + ch] = (1-t) * in[num_channels * j + ch] + t * in[num_channels * (j+1) + ch];
        }
    }
    return num_out_frames * num_channels;
}


// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_quadratic(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels)
{
    if (num_in_frames < 3)
        return ears_resample_linear(in, num_in_frames, out, num_out_frames, factor, num_channels);
    
    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        long j = LONG_MAX;
        double A = 0, B = 0, C = 0;
        for (long s = 0; s < num_out_frames; s++) {
            double x = s / factor;
            long new_j = CLAMP((long)x, 1, num_in_frames-2); // floor
            double t = x - new_j;
            
            if (new_j != j) {
                j = new_j;
                A = 0.5 * (in[num_channels * (j-1) + ch] - 2 * in[num_channels * j + ch] + in[num_channels * (j+1) + ch]);
                B = 0.5 * (in[num_channels * (j+1) + ch] - in[num_channels * (j-1) + ch]);
                C = in[num_channels * j + ch];
            }

            (*out)[num_channels * s + ch] = A * t * t + B * t + C;
        }
    }
    return num_out_frames * num_channels;
}



// beware: <in> should be allocated with num_in_frames * num_channels floats, and <out> might be allocated with num_out_frames * num_channels float
long ears_resample_cubic(float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels)
{
    if (num_in_frames < 4)
        return ears_resample_linear(in, num_in_frames, out, num_out_frames, factor, num_channels);
    
    if (num_out_frames <= 0)
        num_out_frames = (long)ceil(num_in_frames * factor);
    if (out && !*out)
        *out = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
    for (long ch = 0; ch < num_channels; ch++) {
        long j = LONG_MAX;
        double A = 0, B = 0, C = 0, D = 0;
        for (long s = 0; s < num_out_frames; s++) {
            double x = s / factor;
            long new_j = CLAMP((long)x, 1, num_in_frames-3); // floor
            double t = x - new_j;
            double tsq = t * t;

            if (new_j != j) {
                j = new_j;
                A = (-in[num_channels * (j-1) + ch] + 3 * in[num_channels * (j) + ch] - 3 * in[num_channels * (j+1) + ch] + in[num_channels * (j+2) + ch]) / 6.;
                B = (3 * in[num_channels * (j-1) + ch] - 6 * in[num_channels * (j) + ch] + 3 * in[num_channels * (j+1) + ch]) / 6.;
                C = (-2 * in[num_channels * (j-1) + ch] - 3 * in[num_channels * (j) + ch] + 6 * in[num_channels * (j+1) + ch] - in[num_channels * (j+2) + ch]) / 6.;
                D = in[num_channels * j + ch];
            }

            (*out)[num_channels * s + ch] = A * tsq * t + B * tsq + C * t + D;
        }
    }
    return num_out_frames * num_channels;
}


long ears_resample(e_ears_resamplingmode resamplingmode, float *in, long num_in_frames, float **out, long num_out_frames, double factor, long num_channels, double fmax, double sr, double window_width)
{
    switch (resamplingmode) {
        case EARS_RESAMPLINGMODE_NEARESTNEIGHBOR:
            return ears_resample_nearestneighbor(in, num_in_frames, out, num_out_frames, factor, num_channels);
            break;
            
        case EARS_RESAMPLINGMODE_SAMPLEANDHOLD:
            return ears_resample_sampleandhold(in, num_in_frames, out, num_out_frames, factor, num_channels);
            break;
        
        case EARS_RESAMPLINGMODE_LINEAR:
            return ears_resample_linear(in, num_in_frames, out, num_out_frames, factor, num_channels);
            break;
        
        case EARS_RESAMPLINGMODE_QUADRATIC:
            return ears_resample_quadratic(in, num_in_frames, out, num_out_frames, factor, num_channels);
            break;

        case EARS_RESAMPLINGMODE_CUBIC:
            return ears_resample_cubic(in, num_in_frames, out, num_out_frames, factor, num_channels);
            break;

        case EARS_RESAMPLINGMODE_SINC:
        default:
            return ears_resample_sinc(in, num_in_frames, out, num_out_frames, factor, num_channels, fmax, sr, window_width);
            break;
    }
}


// resampling without converting sr
t_ears_err ears_buffer_resample(t_object *ob, t_buffer_obj *buf, double resampling_factor, long window_width, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    double curr_sr = buffer_getsamplerate(buf);
    double factor = resampling_factor;
    double sr = curr_sr * factor;
    
    double fmax = sr / 2.;
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        long new_framecount = (long)ceil(framecount * factor);
        float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
        sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
        
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_size_samps(ob, buf, new_framecount);
        sample = ears_buffer_locksamples(buf);
        
        new_framecount = buffer_getframecount(buf);

        if (!sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
//            ears_resample(temp, framecount, &sample, new_framecount, factor, channelcount, fmax, sr, window_width);
            switch (resamplingmode) {
                case EARS_RESAMPLINGMODE_NEARESTNEIGHBOR:
                    ears_resample_nearestneighbor(temp, framecount, &sample, new_framecount, factor, channelcount);
                    break;
                    
                case EARS_RESAMPLINGMODE_SAMPLEANDHOLD:
                    ears_resample_sampleandhold(temp, framecount, &sample, new_framecount, factor, channelcount);
                    break;
                
                case EARS_RESAMPLINGMODE_LINEAR:
                    ears_resample_linear(temp, framecount, &sample, new_framecount, factor, channelcount);
                    break;
                
                case EARS_RESAMPLINGMODE_QUADRATIC:
                    ears_resample_quadratic(temp, framecount, &sample, new_framecount, factor, channelcount);
                    break;

                case EARS_RESAMPLINGMODE_CUBIC:
                    ears_resample_cubic(temp, framecount, &sample, new_framecount, factor, channelcount);
                    break;

                case EARS_RESAMPLINGMODE_SINC:
                default:
                    ears_resample_sinc(temp, framecount, &sample, new_framecount, factor, channelcount, fmax, sr, window_width);
                    break;
            }
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
        }
        bach_freeptr(temp);
    }
    
    return err;
}


// THIS ONE IS EXPERIMENTAL
// resampling without converting sr
t_ears_err ears_buffer_resample_envelope_speed_circualar(t_object *ob, t_buffer_obj *buf, double factor_start, double factor_end, double factor_factor, long window_width, long maxlen_samps)
{
    t_ears_err err = EARS_ERR_NONE;
    double curr_sr = buffer_getsamplerate(buf);
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        float *outsample = NULL;
        long out_framecount = ears_resample_sinc_env_speed_circular(sample, framecount, &outsample, factor_start, factor_end, factor_factor, channelcount, curr_sr, window_width, maxlen_samps);
        
        ears_buffer_unlocksamples(buf);

        ears_buffer_set_size_samps(ob, buf, out_framecount);
        
        float *sample = ears_buffer_locksamples(buf);
        
        if (!sample) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        } else {
            bach_copyptr(outsample, sample, out_framecount * sizeof(float));
            bach_freeptr(outsample);
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
        }
    }
    
    return err;
}



// resampling without converting sr
t_ears_err ears_buffer_resample_envelope(t_object *ob, t_buffer_obj *buf, t_llll *resampling_factor, long window_width, e_slope_mapping slopemapping)
{
    t_ears_err err = EARS_ERR_NONE;
    t_ears_envelope_iterator eei = ears_envelope_iterator_create(resampling_factor, 1., false, slopemapping);
    double curr_sr = buffer_getsamplerate(buf);
    double maxfactor = ears_envelope_iterator_get_max_y(&eei);
    double sr = curr_sr * maxfactor;
    
    double fmax = sr / 2.;
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        long new_framecount = (long)ceil(framecount * maxfactor);
        float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
        sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
        
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_size_samps(ob, buf, new_framecount);
        sample = ears_buffer_locksamples(buf);
        
        new_framecount = buffer_getframecount(buf);
        
        if (!sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            ears_envelope_iterator_reset(&eei);
            long out_samps_times_channels = ears_resample_sinc_env(temp, framecount, &sample, new_framecount, &eei, channelcount, fmax, sr, window_width);
            long out_framecount = out_samps_times_channels / channelcount;
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
            ears_buffer_set_size_samps_preserve(ob, buf, out_framecount);
        }
        bach_freeptr(temp);
    }
    
    return err;
}


// resamples
t_ears_err ears_buffer_convert_sr(t_object *ob, t_buffer_obj *buf, double sr, long resampling_filter_size)
{
    t_ears_err err = EARS_ERR_NONE;
    double curr_sr = buffer_getsamplerate(buf);
    double factor = sr/curr_sr;
    
    long window_width = resampling_filter_size;
    double fmax = sr / 2.;
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        long new_framecount = (long)ceil(framecount * factor);
        float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
        sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
        
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_size_samps(ob, buf, new_framecount);
        ears_buffer_set_sr(ob, buf, sr);
        sample = ears_buffer_locksamples(buf);
        new_framecount   = buffer_getframecount(buf);

        if (!sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            ears_resample_sinc(temp, framecount, &sample, new_framecount, factor, channelcount, fmax, sr, resampling_filter_size);
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
        }
        bach_freeptr(temp);
    }
    return err;
}


// keeps the buffer content while changing the number of channels
// REPAN mode is not supported by this function
t_ears_err ears_buffer_set_numchannels_preserve(t_object *ob, t_buffer_obj *buf, long new_numchannels, e_ears_channel_convert_modes mode)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
        sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
        
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_numchannels(ob, buf, new_numchannels);
        sample = ears_buffer_locksamples(buf);
        
        if (!sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {

            memset(sample, 0, framecount * new_numchannels * sizeof(float));
            
            switch (mode) {
                case EARS_CHANNELCONVERTMODE_CLEAR:
                    break;
                    
                case EARS_CHANNELCONVERTMODE_KEEP:
                    for (long i = 0; i < framecount; i++)
                        for (long c = 0; c < MIN(channelcount, new_numchannels); c++)
                            sample[i*new_numchannels + c] = temp[i*channelcount + c];
                    break;

                case EARS_CHANNELCONVERTMODE_PAD:
                    for (long c = 0; c < new_numchannels; c++) {
                        long c_wk = (c < channelcount ? c : channelcount - 1);
                        for (long i = 0; i < framecount; i++)
                            sample[i*new_numchannels + c] = temp[i*channelcount + c_wk];
                    }
                    break;

                case EARS_CHANNELCONVERTMODE_CYCLE:
                    if (new_numchannels > channelcount) { // upmixing
                        for (long c = 0; c < new_numchannels; c++) {
                            long c_mod = c % channelcount;
                            for (long i = 0; i < framecount; i++)
                                sample[i*new_numchannels + c] = temp[i*channelcount + c_mod];
                        }
                    } else { // downmixing
                        for (long c = 0; c < channelcount; c++) {
                            long c_mod = c % new_numchannels;
                            for (long i = 0; i < framecount; i++)
                                sample[i*new_numchannels + c_mod] += temp[i*channelcount + c];
                        }
                    }
                    break;
                    
                case EARS_CHANNELCONVERTMODE_PALINDROME:
                    if (new_numchannels > channelcount) { // upmixing
                        for (long c = 0; c < new_numchannels; c++) {
                            long c_mod = c % (2 * channelcount);
                            if (c_mod >= channelcount)
                                c_mod = 2 * channelcount - c_mod - 1;
                            for (long i = 0; i < framecount; i++)
                                sample[i*new_numchannels + c] = temp[i*channelcount + c_mod];
                        }
                    } else {
                        for (long c = 0; c < channelcount; c++) {
                            long c_mod = c % (2 * new_numchannels);
                            if (c_mod >= new_numchannels)
                                c_mod = 2 * new_numchannels - c_mod - 1;
                            for (long i = 0; i < framecount; i++)
                                sample[i*new_numchannels + c_mod] += temp[i*channelcount + c];
                        }
                    }
                    break;
                    
                default:
                    break;
            }
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
        }
        bach_freeptr(temp);
    }
    return err;
}

t_ears_err ears_buffer_convert_numchannels(t_object *ob, t_buffer_obj *buf, long numchannels, e_ears_channel_convert_modes channelmode_upmix, e_ears_channel_convert_modes channelmode_downmix)
{
    t_ears_err err = EARS_ERR_NONE;
    long num_orig_channels = buffer_getchannelcount(buf);

    if (numchannels < num_orig_channels) {
        switch (channelmode_downmix) {
            case EARS_CHANNELCONVERTMODE_PAN:
                ears_buffer_pan1d(ob, buf, buf, numchannels, 0.5, EARS_PAN_MODE_LINEAR, EARS_PAN_LAW_COSINE, 1., true);
                break;
                
            default:
                ears_buffer_set_numchannels_preserve(ob, buf, numchannels, channelmode_downmix);
                break;
        }
    } else if (numchannels > num_orig_channels) {

        switch (channelmode_upmix) {
            case EARS_CHANNELCONVERTMODE_PAN:
                ears_buffer_pan1d(ob, buf, buf, numchannels, 0.5, EARS_PAN_MODE_LINEAR, EARS_PAN_LAW_COSINE, 1., false);
                break;
                
            default:
                ears_buffer_set_numchannels_preserve(ob, buf, numchannels, channelmode_upmix);
                break;
        }
    }
    
    
    return err;
}


// like ears_buffer_set_size_samps() but keeps the samples
t_ears_err ears_buffer_convert_size(t_object *ob, t_buffer_obj *buf, long sizeinsamps)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        float *temp = (float *)bach_newptr(channelcount * framecount * sizeof(float));
        sysmem_copyptr(sample, temp, channelcount * framecount * sizeof(float));
        
        ears_buffer_unlocksamples(buf);
        ears_buffer_set_size_samps(ob, buf, sizeinsamps);
        sample = ears_buffer_locksamples(buf);
        
        if (!sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            t_atom_long	new_framecount = buffer_getframecount(buf);			// should be always equal to sizeinsamps!
            sysmem_copyptr(temp, sample, channelcount * MIN(new_framecount, framecount) * sizeof(float));
            buffer_setdirty(buf);
            ears_buffer_unlocksamples(buf);
        }
        bach_freeptr(temp);
    }
    return err;
}



// Different from ears_buffer_copy_format() because it resamples and also downmixes/upmixes
t_ears_err ears_buffer_convert_format(t_object *ob, t_buffer_obj *orig, t_buffer_obj *dest, e_ears_channel_convert_modes channelmode_upmix, e_ears_channel_convert_modes channelmode_downmix, long resampling_filter_size)
{
    if (!orig || !dest) {
        object_error((t_object *)ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    t_atom_long	orig_channelcount = buffer_getchannelcount(orig);		// number of floats in a frame
    double orig_sr = buffer_getsamplerate(orig);          // sample rate of the buffer in samples per second
    
    t_atom_long	dest_channelcount = buffer_getchannelcount(dest);
    double dest_sr = buffer_getsamplerate(dest);
    
    if (dest_sr != orig_sr)
        ears_buffer_convert_sr(ob, dest, orig_sr, resampling_filter_size);
    
    if (dest_channelcount != orig_channelcount)
        ears_buffer_convert_numchannels(ob, dest, orig_channelcount, channelmode_upmix, channelmode_downmix);
    
//    dest_channelcount = buffer_getchannelcount(dest);
//    dest_sr = buffer_getsamplerate(dest);
    
    return EARS_ERR_NONE;
}


// N.B. end_sample is EXCLUDED!!!! The taken interval is [start_sample end_sample[
// end_sample is then the FIRST sample of the region after the crop
t_ears_err ears_buffer_crop(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long start_sample, long end_sample)
{
    if (source == dest)
        return ears_buffer_crop_inplace(ob, source, start_sample, end_sample);
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        if (!buffer_getframecount(source)) {
            object_warn((t_object *)ob, "Source buffer is empty!");
            ears_buffer_set_size_samps(ob, dest, 0);
        } else {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        }
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (start_sample < 0) start_sample += framecount;
        if (start_sample < 0) start_sample = 0;
        CLIP_ASSIGN(start_sample, 0, framecount);
        if (end_sample < 0) end_sample += framecount;
        if (end_sample < 0) end_sample = 0;
        CLIP_ASSIGN(end_sample, 0, framecount);

        if (start_sample == framecount) {
            object_warn((t_object *)ob, "Starting crop point comes after the buffer end: empty buffer output.");
            ears_buffer_set_size_samps(ob, dest, 0);
            
        } else if (end_sample <= start_sample) {
            object_warn((t_object *)ob, "Ending crop point precedes or coincides with starting crop point: empty buffer output.");
            ears_buffer_set_size_samps(ob, dest, 0);

        } else {
            
            long new_dest_frames = end_sample - start_sample;
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, new_dest_frames);

            t_atom_long dest_channelcount = buffer_getchannelcount(dest);
            float *dest_sample = ears_buffer_locksamples(dest);
            
            if (!dest_sample) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
            } else {
                sysmem_copyptr(orig_sample + start_sample * channelcount, dest_sample, new_dest_frames * dest_channelcount * sizeof(float));
                buffer_setdirty(dest);
                ears_buffer_unlocksamples(dest);
            }
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_crop_ms(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double start_ms, double end_ms)
{
    float msr = buffer_getmillisamplerate(source);
    long start_sample = round(start_ms * msr);
    long end_sample = round(end_ms * msr);
    
    return ears_buffer_crop(ob, source, dest, start_sample, end_sample);
}



// N.B. end_sample is EXCLUDED!!!! The taken interval is [start_sample end_sample[
// end_sample is then the FIRST sample of the region after the crop
t_ears_err ears_buffer_crop_inplace(t_object *ob, t_buffer_obj *buf, long start_sample, long end_sample)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        if (!buffer_getframecount(buf)) {
            object_warn((t_object *)ob, "Source buffer is empty!");
            ears_buffer_set_size_samps(ob, buf, 0);
        } else {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        }
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        if (start_sample < 0) start_sample = 0;
        CLIP_ASSIGN(start_sample, 0, framecount);
        if (end_sample < 0) end_sample = framecount;
        CLIP_ASSIGN(end_sample, 0, framecount);
        
        if (start_sample == framecount) {
            object_warn((t_object *)ob, "Starting crop point comes after the buffer end: empty buffer output.");
            ears_buffer_set_size_samps(ob, buf, 0);
            
        } else if (end_sample <= start_sample) {
            object_warn((t_object *)ob, "Ending crop point precedes or coincides with starting crop point: empty buffer output.");
            ears_buffer_set_size_samps(ob, buf, 0);
            
        } else {
            
            long new_dest_frames = end_sample - start_sample;
            float *temp = (float *)bach_newptr(channelcount * new_dest_frames * sizeof(float));
            sysmem_copyptr(sample + start_sample * channelcount, temp, channelcount * new_dest_frames * sizeof(float));
            
            ears_buffer_unlocksamples(buf);
            ears_buffer_set_size_samps(ob, buf, new_dest_frames);
            sample = ears_buffer_locksamples(buf);
            
            if (!sample) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
            } else {
                sysmem_copyptr(temp, sample, channelcount * new_dest_frames * sizeof(float));
                buffer_setdirty(buf);
            }
            
            bach_freeptr(temp);
        }
        ears_buffer_unlocksamples(buf);
    }
    return err;
}


t_ears_err ears_buffer_crop_ms_inplace(t_object *ob, t_buffer_obj *buf, double start_ms, double end_ms)
{
    float msr = buffer_getmillisamplerate(buf);
    long start_sample = round(start_ms * msr);
    long end_sample = round(end_ms * msr);
    
    return ears_buffer_crop_inplace(ob, buf, start_sample, end_sample);
}




t_ears_err ears_buffer_clone(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    if (source == dest) // nothing to clone
        return EARS_ERR_NONE;
    
    // we do not use the "duplicate" message because we do not have control on it.
    // For instance, "duplicate" doesn't copy the buffer format.
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel

        ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);

        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            sysmem_copyptr(orig_sample, dest_sample, framecount * channelcount * sizeof(float));
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


// split sample is the first sample of the right portion
t_ears_err ears_buffer_slice(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest_left, t_buffer_obj *dest_right, long split_sample)
{
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        if (!buffer_getframecount(source)) {
            object_warn((t_object *)ob, "Source buffer is empty!");
            ears_buffer_set_size_samps(ob, dest_left, 0);
            ears_buffer_set_size_samps(ob, dest_right, 0);
        } else {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        }
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (split_sample < 0) split_sample += framecount;
        if (split_sample < 0) split_sample = 0;
        CLIP_ASSIGN(split_sample, 0, framecount);
        
        if (split_sample == framecount) {
            ears_buffer_clone(ob, source, dest_left);
            ears_buffer_set_size_samps(ob, dest_right, 0);

        } else if (split_sample == 0) {
            ears_buffer_clone(ob, source, dest_right);
            ears_buffer_set_size_samps(ob, dest_left, 0);

        } else {
            ears_buffer_clone(ob, source, dest_left);
            ears_buffer_clone(ob, source, dest_right);

            ears_buffer_set_size_and_numchannels(ob, dest_left, split_sample, channelcount);
            ears_buffer_set_size_and_numchannels(ob, dest_right, framecount - split_sample, channelcount);
            t_atom_long dest_left_channelcount = buffer_getchannelcount(dest_left);
            t_atom_long dest_right_channelcount = buffer_getchannelcount(dest_right);
            
            float *dest_left_sample = ears_buffer_locksamples(dest_left);
            if (!dest_left_sample) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
            } else {
                sysmem_copyptr(orig_sample, dest_left_sample, split_sample * dest_left_channelcount * sizeof(float));
                buffer_setdirty(dest_left);
                ears_buffer_unlocksamples(dest_left);
            }

            float *dest_right_sample = ears_buffer_locksamples(dest_right);
            if (!dest_left_sample) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
            } else {
                sysmem_copyptr(orig_sample + split_sample * channelcount, dest_right_sample, (framecount - split_sample) * dest_right_channelcount * sizeof(float));
                buffer_setdirty(dest_right);
                ears_buffer_unlocksamples(dest_right);
            }
            
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


// extract multiple regions from a buffer
// all ** must be allocated of size <num_regions>
t_ears_err ears_buffer_split(t_object *ob, t_buffer_obj *source, t_buffer_obj **dest, long *start_samples, long *end_samples, long num_regions)
{
    t_ears_err err = EARS_ERR_NONE;
    if (num_regions > 0) {
        float *orig_sample = ears_buffer_locksamples(source);
        
        if (!orig_sample) {
            if (!buffer_getframecount(source)) {
                object_warn((t_object *)ob, "Source buffer is empty!");
                for (long i = 0; i < num_regions; i++)
                    ears_buffer_set_size_samps(ob, dest[i], 0);
            } else {
                err = EARS_ERR_CANT_READ;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
            }
        } else {
            t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
            t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
            
            for (long i = 0; i < num_regions; i++) {
                t_buffer_obj *this_dest = dest[i];
                long this_start = start_samples[i];
                long this_end = end_samples[i];
                if (this_start < 0) this_start += framecount;
                if (this_start < 0) this_start = 0;
                CLIP_ASSIGN(this_start, 0, framecount-1);
                if (this_end < 0) this_end += framecount;
                if (this_end < 0) this_end = 0;
                CLIP_ASSIGN(this_end, 0, framecount);
                if (this_end < this_start) {
                    long temp = this_start; this_start = this_end; this_end = temp;
                }

                if (this_end == this_start) {
                    ears_buffer_set_size_samps(ob, this_dest, 0);
                    
                } else {
                    ears_buffer_copy_format_and_set_size_samps(ob, source, this_dest, this_end - this_start);
                    t_atom_long dest_channelcount = buffer_getchannelcount(this_dest);
                    t_atom_long dest_framecount = buffer_getframecount(this_dest);
                    
                    if (dest_channelcount != channelcount) {
                        object_error(ob, "Mismatch in channel count!");
                    }
                    if (this_end-this_start != dest_framecount) {
                        object_error(ob, "Mismatch in frame count!");
                    }

                    float *dest_sample = ears_buffer_locksamples(this_dest);
                    if (!dest_sample) {
                        err = EARS_ERR_CANT_WRITE;
                        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
                    } else {
                        sysmem_copyptr(orig_sample + this_start * channelcount, dest_sample, (this_end - this_start) * channelcount * sizeof(float));
                        buffer_setdirty(this_dest);
                        ears_buffer_unlocksamples(this_dest);
                    }
                }
            }
            
            ears_buffer_unlocksamples(source);
        }
    } else {
        err = EARS_ERR_GENERIC;
        object_error((t_object *)ob, EARS_ERROR_BUF_NO_SEGMENTS);
    }
    
    return err;
}




void ears_buffer_preprocess_sr_single(t_object *ob, double target_sr, t_buffer_obj *factor, float **factor_sample, long resamplingfiltersize, e_ears_resamplingmode resamplingmode, bool *resampled, t_atom_long *new_factor_sample)
{
    // Do we need to resample factor?
    double this_sr = ears_buffer_get_sr(ob, factor);
    if (this_sr != target_sr) {
        // must resample
        long num_channels = ears_buffer_get_numchannels(ob, factor);
        double resampling_factor = (target_sr/this_sr);
        long num_in_frames = ears_buffer_get_size_samps(ob, factor);
        long num_out_frames = ceil(num_in_frames * resampling_factor);
        float *new_samples = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
        ears_resample_sinc(*factor_sample, num_in_frames, &new_samples, num_out_frames, resampling_factor, num_channels, this_sr/2., this_sr, resamplingfiltersize);
        ears_buffer_unlocksamples(factor);
        *factor_sample = new_samples;
        *resampled = true;
        *new_factor_sample = num_out_frames;
    }
}



t_ears_err ears_buffer_sumchannel(t_object *ob, t_buffer_obj *source, long source_channel, t_buffer_obj *dest, long dest_channel, double resampling_sr, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    bool resampled = false;
    double sr = ears_buffer_get_sr(ob, source);
    float *source_sample = ears_buffer_locksamples(source);
    
    if (!source_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long    source_channelcount = buffer_getchannelcount(source);
        t_atom_long    source_framecount   = buffer_getframecount(source);
        
        if (resampling_sr > 0 && sr != resampling_sr) {
            ears_buffer_preprocess_sr_single(ob, resampling_sr, source, &source_sample, resamplingfiltersize, resamplingmode, &resampled, &source_framecount);
        }
        
        float *dest_sample = ears_buffer_locksamples(dest);
        if (!dest_sample) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        } else {
            t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
            t_atom_long    dest_framecount   = buffer_getframecount(dest);
            
            for (long i = 0; i < source_framecount && i < dest_framecount; i++) {
                dest_sample[i * dest_channelcount + dest_channel] += source_sample[i * source_channelcount + source_channel];
            }
            ears_buffer_unlocksamples(dest);
        }
        
        if (resampled)
            bach_freeptr(source_sample);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}

t_ears_err ears_buffer_clearchannel(t_object *ob, t_buffer_obj *buf, long channel)
{
    if (!buf)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);
        t_atom_long    framecount   = buffer_getframecount(buf);

        if (channel >= 0 && channel < channelcount) {
            for (long f = 0; f < framecount; f++) {
                sample[f * channelcount + channel] = 0;
            }
        }
        buffer_setdirty(buf);
        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}

t_ears_err ears_buffer_copychannel(t_object *ob, t_buffer_obj *source, long source_channel, t_buffer_obj *dest, long dest_channel, double resampling_sr, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    bool resampled = false;
    double sr = ears_buffer_get_sr(ob, source);
    float *source_sample = ears_buffer_locksamples(source);
    
    if (!source_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long    source_channelcount = buffer_getchannelcount(source);
        t_atom_long    source_framecount   = buffer_getframecount(source);

        if (resampling_sr > 0 && sr != resampling_sr) {
            ears_buffer_preprocess_sr_single(ob, resampling_sr, source, &source_sample, resamplingfiltersize, resamplingmode, &resampled, &source_framecount);
        }
        
        float *dest_sample = ears_buffer_locksamples(dest);
        if (!dest_sample) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        } else {
            t_atom_long	dest_channelcount = buffer_getchannelcount(dest);
            t_atom_long	dest_framecount   = buffer_getframecount(dest);

            for (long i = 0; i < source_framecount && i < dest_framecount; i++) {
                dest_sample[i * dest_channelcount + dest_channel] = source_sample[i * source_channelcount + source_channel];
            }
            ears_buffer_unlocksamples(dest);
        }
        
        if (resampled)
            bach_freeptr(source_sample);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_setempty(t_object *ob, t_buffer_obj *buf, long num_channels)
{
    ears_buffer_set_size_and_numchannels(ob, buf, 0, num_channels);
    ears_buffer_set_sr(ob, buf, sys_getsr());
    return EARS_ERR_NONE;
}


t_ears_err ears_buffer_extractchannels(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long num_channels, long *channels)
{
    t_ears_err this_err, err = EARS_ERR_NONE;
    long frames = ears_buffer_get_size_samps(ob, source);
    ears_buffer_copy_format(ob, source, dest, true); // won't change buffer size: we'll set size/numchannels later
    ears_buffer_set_size_and_numchannels(ob, dest, frames, num_channels);
    for (long i = 0; i < num_channels; i++)
        if ((this_err = ears_buffer_copychannel(ob, source, channels[i], dest, i)) != EARS_ERR_NONE)
            err = this_err;
    return err;
}


t_ears_err ears_buffer_extractchannels_from_llll(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, t_llll *channels)
{
    long num_source_channels = ears_buffer_get_numchannels(ob, source);
    t_llll *temp = llll_clone(channels);
    llll_develop_ranges_and_parse_negative_indices_inplace(&temp, num_source_channels, true);
    
    long num_channels = temp->l_size;
    if (num_channels == 0)
        return ears_buffer_extractchannels(ob, source, dest, 0, NULL);
    else {
        long i = 0;
        long *channels = (long *)bach_newptr(num_channels * sizeof(long));
        for (t_llllelem *el = temp->l_head; el; el = el->l_next, i++)
            channels[i] = hatom_getlong(&el->l_hatom);
        t_max_err err = ears_buffer_extractchannels(ob, source, dest, num_channels, channels);
        bach_freeptr(channels);
        return err;
    }
    
    llll_free(temp);
}


void ears_buffer_preprocess_sr_policies_dry(t_object *ob, t_buffer_obj **source, long num_sources, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, double *sr, bool *resampled)
{
    if (!ears_buffers_have_the_same_sr(ob, num_sources, source) && resamplingpolicy != EARS_RESAMPLINGPOLICY_DONT) {
        *resampled = true;
        *sr = ears_buffers_get_collective_sr(ob, num_sources, source, resamplingpolicy);
    }
}


t_ears_err ears_buffer_pack(t_object *ob, long num_sources, t_buffer_obj **source, t_buffer_obj *dest,
                            e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!dest)
        return EARS_ERR_NO_BUFFER;
    
    if (num_sources == 0) {
        // empty buffer, 1 channel
        ears_buffer_setempty(ob, dest, 1);
        return EARS_ERR_NONE;
    }
    
    bool must_resample = false;
    double sr = ears_buffer_get_sr(ob, source[0]);

    ears_buffer_preprocess_sr_policies_dry(ob, source, num_sources, resamplingpolicy, resamplingfiltersize, &sr, &must_resample);

    ears_buffer_set_sr(ob, dest, sr);
    
    long num_channels = 0;
    long max_num_frames = 0;
    for (long i = 0; i < num_sources; i++) {
        num_channels += ears_buffer_get_numchannels(ob, source[i]);
        if (must_resample && sr > 0)
            max_num_frames = MAX(max_num_frames, ceil(ears_buffer_get_size_samps(ob, source[i]) * sr / ears_buffer_get_sr(ob, source[i])));
        else
            max_num_frames = MAX(max_num_frames, ears_buffer_get_size_samps(ob, source[i]));
    }

    ears_buffer_clear(ob, dest);
    ears_buffer_set_size_and_numchannels(ob, dest, max_num_frames, num_channels);

    long channel_cur = 0;
    for (long i = 0; i < num_sources; i++) {
        long this_num_channels = ears_buffer_get_numchannels(ob, source[i]);
        for (long c = 0; c < this_num_channels; c++) {
            t_ears_err this_err = ears_buffer_copychannel(ob, source[i], c, dest, channel_cur, must_resample ? sr : 0, resamplingfiltersize, resamplingmode);
            if (err == EARS_ERR_NONE)
                err = this_err;
            channel_cur++;
        }
    }
    
    return err;
}


t_ears_err ears_buffer_pack_from_llll(t_object *ob, t_llll *sources_ll, t_buffer_obj *dest,
                                      e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    long num_sources = sources_ll->l_size;
    
    if (num_sources == 0)
        return ears_buffer_pack(ob, 0, NULL, dest, resamplingpolicy, resamplingfiltersize, resamplingmode);
    else {
        long i = 0;
        t_buffer_obj **sources = (t_buffer_obj **)bach_newptr(num_sources * sizeof(t_buffer_obj *));
        for (t_llllelem *el = sources_ll->l_head; el; el = el->l_next, i++)
            sources[i] = (t_buffer_obj *)hatom_getobj(&el->l_hatom);
        t_max_err err = ears_buffer_pack(ob, num_sources, sources, dest, resamplingpolicy, resamplingfiltersize, resamplingmode);
        bach_freeptr(sources);
        return err;
    }
}

t_ears_err ears_buffer_lace(t_object *ob, long num_sources, t_buffer_obj **sources, t_buffer_obj *dest)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!dest || num_sources <= 0) {
        object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    for (long i = 0; i < num_sources; i++) {
        if (!sources[i]) {
            object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
            return EARS_ERR_NO_BUFFER;
        }
    }

    long *num_channels = (long *)bach_newptr(num_sources * sizeof(long));
    long *num_samps = (long *)bach_newptr(num_sources * sizeof(long));
    long *count = (long *)bach_newptrclear(num_sources * sizeof(long));
    long tot_num_channels = 0, max_num_samps = 0;
    for (long i = 0; i < num_sources; i++) {
        num_channels[i] = ears_buffer_get_numchannels(ob, sources[i]);
        num_samps[i] = ears_buffer_get_size_samps(ob, sources[i]);
        tot_num_channels += num_channels[i];
        max_num_samps = MAX(max_num_samps, num_samps[i]);
    }
    
    ears_buffer_set_size_and_numchannels(ob, dest, max_num_samps, tot_num_channels);
    
    for (long i = 0; i < tot_num_channels; i++) {
        long j = i % num_sources;
        if (count[j] < num_channels[j]) {
            t_ears_err this_err = ears_buffer_copychannel(ob, sources[j], count[j]++, dest, i);
            if (err == EARS_ERR_NONE)
                err = this_err;
        }
    }
    
    bach_freeptr(num_channels);
    bach_freeptr(num_samps);
    bach_freeptr(count);

    return err;
}

t_ears_err ears_buffer_delace(t_object *ob, t_buffer_obj *source, long num_dests, t_buffer_obj **dests)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!source || num_dests <= 0) {
        object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    for (long i = 0; i < num_dests; i++) {
        if (!dests[i]) {
            object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
            return EARS_ERR_NO_BUFFER;
        }
    }
    
    long num_channels = ears_buffer_get_numchannels(ob, source);
    long num_samps = ears_buffer_get_size_samps(ob, source);
    long *num_channels_dest = (long *)bach_newptrclear(num_dests * sizeof(long));
    long *count = (long *)bach_newptrclear(num_dests * sizeof(long));

    for (long i = 0; i < num_channels; i++) {
        long j = i % num_dests;
        num_channels_dest[j]++;
    }
    for (long j = 0; j < num_dests; j++) {
        ears_buffer_set_size_and_numchannels(ob, dests[j], num_samps, num_channels_dest[j]);
    }
    for (long i = 0; i < num_channels; i++) {
        long j = i % num_dests;
        t_ears_err this_err = ears_buffer_copychannel(ob, source, i, dests[j], count[j]);
        if (err == EARS_ERR_NONE)
            err = this_err;
        count[j]++;
    }
    
    bach_freeptr(num_channels_dest);
    bach_freeptr(count);
    
    return err;
}



t_ears_err ears_buffer_get_minmax(t_object *ob, t_buffer_obj *source, double *ampmin, double *ampmax, long *ampminsample, long *ampmaxsample)
{
    t_ears_err err = EARS_ERR_NONE;
    double min = 0, max = 0;
    long minsample = 0, maxsample = 0;

    float *sample = ears_buffer_locksamples(source);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (framecount == 0) {
            err = EARS_ERR_NO_BUFFER;
        } else {
            max = min = sample[0];
            maxsample = minsample = 0;
            
            for (long i = 0; i < channelcount * framecount; i++) {
                if (sample[i] > max) {
                    max = sample[i];
                    maxsample = i;
                }
                if (sample[i] < min) {
                    min = sample[i];
                    minsample = i;
                }
            }
        }
    }
    
    ears_buffer_unlocksamples(source);
    
    if (ampmin)
        *ampmin = min;
    if (ampmax)
        *ampmax = max;
    if (ampminsample)
        *ampminsample = minsample;
    if (ampmaxsample)
        *ampmaxsample = maxsample;
    return err;
}


t_ears_err ears_buffer_get_maxabs(t_object *ob, t_buffer_obj *source, double *maxabs)
{
    double min = 0, max = 0;
    t_ears_err err = ears_buffer_get_minmax(ob, source, &min, &max);
    min = fabs(min);
    max = fabs(max);
    if (maxabs)
        *maxabs = MAX(min, max);
    return err;
}

t_ears_err ears_buffer_get_rms(t_object *ob, t_buffer_obj *source, double *rms)
{
    t_ears_err err = EARS_ERR_NONE;
    double tot = 0;
    
    float *sample = ears_buffer_locksamples(source);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (framecount == 0) {
            err = EARS_ERR_NO_BUFFER;
            object_error((t_object *)ob, EARS_ERROR_BUF_EMPTY_BUFFER);
        } else {
            for (long i = 0; i < channelcount * framecount; i++)
                tot += sample[i] * sample[i];
            
            tot = sqrt(tot/(channelcount * framecount));
        }
    }
    
    ears_buffer_unlocksamples(source);
    
    if (rms)
        *rms = tot;
    
    return err;
}


// also supports inplace operations
t_ears_err ears_buffer_gain(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double gain_factor, char use_decibels)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        double factor = use_decibels ? ears_db_to_linear(gain_factor) : gain_factor;
        
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
//            ears_buffer_copy_format(ob, source, dest);
//            ears_buffer_set_size_samps(ob, dest, framecount);
        }
        
        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            for (long i = 0; i < channelcount * framecount; i++) {
                dest_sample[i] = orig_sample[i] * factor;
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}



// also supports inplace operations
t_ears_err ears_buffer_clip(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double clip_threshold, char use_decibels)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        double threshold = use_decibels ? ears_db_to_linear(clip_threshold) : clip_threshold;
        
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }

        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            for (long i = 0; i < channelcount * framecount; i++) {
                if (fabs(orig_sample[i]) < threshold)
                    dest_sample[i] = orig_sample[i];
                else
                    dest_sample[i] = (orig_sample[i] >= 0 ? 1 : -1) * threshold;
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}

// like Max's [overdrive] object
double ears_overdrive(double input, double drive)
{
    int signx = (input >= 0. ? 1 : -1);
    return CLAMP(1 - exp(drive * log(1 - input * signx)), 0, 1) * signx;
}

// also supports inplace operations
t_ears_err ears_buffer_overdrive(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double drive)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            for (long i = 0; i < channelcount * framecount; i++) {
                dest_sample[i] = ears_overdrive(orig_sample[i], drive);
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}








double min_circular_dist(double v1, double v2, double modulo)
{
    v1 = positive_fmod(v1, modulo);
    v2 = positive_fmod(v2, modulo);
    double m1 = MIN(v1, v2);
    double m2 = MAX(v1, v2);
    return MIN(fabs(m1 - m2), fabs(m1 + modulo - m2));
}


// pan must be between 0 and 1
float ears_get_pan_factor(long channel, long num_channels, double pan, e_ears_pan_modes pan_mode, e_ears_pan_laws pan_law)
{
    if (num_channels <= 1)
        return 1.;
    
    switch (pan_mode) {
        case EARS_PAN_MODE_LINEAR:
            pan *= num_channels - 1;
            
            switch (pan_law) {
                case EARS_PAN_LAW_NEAREST_NEIGHBOR:
                    return (channel == (long)round(pan));
                    
                case EARS_PAN_LAW_COSINE:
                    if (pan > channel + 1)
                        return 0.;
                    if (pan < channel - 1)
                        return 0.;
                    return cos(fabs(pan - channel) * PIOVERTWO);
            }
            break;
            
        default:
            pan *= num_channels;
            pan = fmod(pan, num_channels);
            
            switch (pan_law) {
                case EARS_PAN_LAW_NEAREST_NEIGHBOR:
                    return (channel == (long)round(pan));
                    
                case EARS_PAN_LAW_COSINE:
                {
                    double mindist = min_circular_dist(pan, channel, num_channels);
                    if (mindist < 1)
                        return cos(mindist * PIOVERTWO);
                    else
                        return 0.;
                }
            }
            break;
    }
}


// pan goes between 0 and 1
double multichannel_pan(double pan, e_ears_pan_modes pan_mode, long channelcount, long channel, double aperture)
{
    double out_pan = pan;
    
    if (channelcount <= 1)
        return out_pan; // that's the trivial case
    
    double ccm1d2 = (channelcount - 1)/2.;
    double delta_channel = (channel / ccm1d2) - 1; // this goes from -1 to 1 and is exactly 0 for the middle channels.
                                                                   // it is -1 for the first channel and 1 for the last
    switch (pan_mode) {
        case EARS_PAN_MODE_CIRCULAR:
            out_pan = positive_fmod(pan + delta_channel * (ccm1d2 / channelcount) * aperture, 1.);
            break;
            
        case EARS_PAN_MODE_LINEAR:
        {
            double temp = MAX(0, MIN(pan, 1. - pan));
            out_pan = pan + delta_channel * temp * aperture;
        }
            break;
            
        default:
            break;
    }
    
    return out_pan;
}


// pan goes between 0 and 1
// Should also work "inplace" when source = dest
t_ears_err ears_buffer_pan1d(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long num_out_channels, double pan, e_ears_pan_modes pan_mode, e_ears_pan_laws pan_law, double multichannel_pan_aperture, char compensate_gain_for_multichannel_to_avoid_clipping)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);
        t_atom_long	framecount   = buffer_getframecount(source);
        
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change channels/framecount: that'll be done later on
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, framecount, num_out_channels);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            if (channelcount == 1) { // panning a mono source
                
                double pan_factor[EARS_MAX_NUM_CHANNELS]; // panning factors for each channel, and for each
                for (long c = 0; c < num_out_channels; c++)
                    pan_factor[c] = ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                
                for (long i = 0; i < framecount; i++)
                    for (long c = 0; c < num_out_channels; c++)
                        dest_sample[i*num_out_channels + c] = orig_sample_wk[i] * pan_factor[c];
            } else {
                if (multichannel_pan_aperture == 0) {
                    double pan_factor[EARS_MAX_NUM_CHANNELS]; // panning factors for each channel
                    for (long c = 0; c < num_out_channels; c++) {
                        pan_factor[c] = ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                        if (compensate_gain_for_multichannel_to_avoid_clipping)
                            pan_factor[c] /= channelcount;
                    }

                    for (long i = 0; i < framecount; i++) {
                        // mixdown to mono before panning
                        double s = 0;
                        for (long c = 0; c < channelcount; c++)
                            s += orig_sample_wk[i*channelcount + c];
                        
                        for (long c = 0; c < num_out_channels; c++)
                            dest_sample[i*num_out_channels + c] = s * pan_factor[c];
                    }
                } else {
                    double *pan_factor = (double *)bach_newptr(num_out_channels * channelcount * sizeof(double));
                    double adjusted_pan[EARS_MAX_NUM_CHANNELS]; // panning position for each channel
                    for (long d = 0; d < channelcount; d++)
                        adjusted_pan[d] = multichannel_pan(pan, pan_mode, channelcount, d, multichannel_pan_aperture);
                    for (long c = 0; c < num_out_channels; c++)
                        for (long d = 0; d < channelcount; d++) { // spreading each input channel to a different position
                            pan_factor[c * channelcount + d] = ears_get_pan_factor(c, num_out_channels, adjusted_pan[d], pan_mode, pan_law) / (compensate_gain_for_multichannel_to_avoid_clipping ? channelcount : 1);
                        }

                    
                    memset(dest_sample, 0, framecount * num_out_channels * sizeof(float));
                    
                    for (long i = 0; i < framecount; i++) {
                        for (long c = 0; c < num_out_channels; c++)
                            for (long d = 0; d < channelcount; d++)
                                dest_sample[i * num_out_channels + c] += orig_sample_wk[i * channelcount + d] * pan_factor[c * channelcount + d];
                    }
                    bach_freeptr(pan_factor);
                }
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}



t_ears_err ears_buffer_pan1d_envelope(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long num_out_channels, t_llll *env, e_ears_pan_modes pan_mode, e_ears_pan_laws pan_law, double multichannel_pan_aperture, char compensate_gain_for_multichannel_to_avoid_clipping, e_slope_mapping slopemapping)
{
    
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;

    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);
        t_atom_long	framecount   = buffer_getframecount(source);

        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change channels/framecount: that'll be done later on
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, framecount, num_out_channels);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            t_ears_envelope_iterator eei = ears_envelope_iterator_create(env, 0., false, slopemapping);
            
            if (channelcount == 1) { // panning a mono source
                for (long i = 0; i < framecount; i++) {
                    double pan = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                    for (long c = 0; c < num_out_channels; c++)
                        dest_sample[i*num_out_channels + c] = orig_sample_wk[i] * ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                }
            } else {
                if (multichannel_pan_aperture == 0) {
                    
                    for (long i = 0; i < framecount; i++) {
                        // mixdown to mono before panning
                        double s = 0;
                        for (long c = 0; c < channelcount; c++)
                            s += orig_sample_wk[i*channelcount + c];
                        if (compensate_gain_for_multichannel_to_avoid_clipping)
                            s /= channelcount;
                        
                        double pan = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                        for (long c = 0; c < num_out_channels; c++)
                            dest_sample[i*num_out_channels + c] = s * ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                    }
                } else {
                    double adjusted_pan[EARS_MAX_NUM_CHANNELS]; // panning position for each channel
                    for (long i = 0; i < framecount; i++) {
                        double pan = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                        for (long d = 0; d < channelcount; d++)
                            adjusted_pan[d] = multichannel_pan(pan, pan_mode, channelcount, d, multichannel_pan_aperture);
                        for (long c = 0; c < num_out_channels; c++)
                            for (long d = 0; d < channelcount; d++)
                                dest_sample[i * num_out_channels + c] += orig_sample_wk[i * channelcount + d] * ears_get_pan_factor(c, num_out_channels, adjusted_pan[d], pan_mode, pan_law) / (compensate_gain_for_multichannel_to_avoid_clipping ? channelcount : 1);
                    }
                }
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }

        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}



t_ears_err ears_buffer_pan1d_buffer(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long num_out_channels, t_buffer_obj *pan, e_ears_pan_modes pan_mode, e_ears_pan_laws pan_law, double multichannel_pan_aperture, char compensate_gain_for_multichannel_to_avoid_clipping)
{
    if (!source || !pan || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *source_sample = ears_buffer_locksamples(source);
    float *source_sample_wk = NULL;

    if (!source_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    source_channelcount = buffer_getchannelcount(source);
        t_atom_long    source_framecount   = buffer_getframecount(source);
        
        if (source == dest) { // inplace operation!
            source_sample_wk = (float *)bach_newptr(source_channelcount * source_framecount * sizeof(float));
            sysmem_copyptr(source_sample, source_sample_wk, source_channelcount * source_framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            source_sample_wk = source_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change channels/framecount: that'll be done later on
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, source_framecount, num_out_channels);

//        t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
//        t_atom_long    dest_framecount   = buffer_getframecount(dest);
 
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            float *pan_sample = ears_buffer_locksamples(pan);
            
            if (!pan_sample) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
            } else {
                
                t_atom_long	pan_channelcount = buffer_getchannelcount(pan);
                t_atom_long	pan_framecount   = buffer_getframecount(pan);
                
                if (pan_channelcount >= 1) {
                    long max_sample = MIN(source_framecount, pan_framecount);
                    
                    if (source_channelcount == 1) { // panning a mono source
                        for (long i = 0; i < max_sample; i++) {
                            double pan = pan_sample[i];
                            for (long c = 0; c < num_out_channels; c++)
                                dest_sample[i*num_out_channels + c] = source_sample_wk[i] * ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                        }
                    } else {
                        if (multichannel_pan_aperture == 0) {
                            
                            for (long i = 0; i < max_sample; i++) {
                                // mixdown to mono before panning
                                double s = 0;
                                for (long c = 0; c < source_channelcount; c++)
                                    s += source_sample_wk[i*source_channelcount + c];
                                if (compensate_gain_for_multichannel_to_avoid_clipping)
                                    s /= source_channelcount;
                                
                                double pan = pan_sample[i];
                                for (long c = 0; c < num_out_channels; c++)
                                    dest_sample[i*num_out_channels + c] = s * ears_get_pan_factor(c, num_out_channels, pan, pan_mode, pan_law);
                            }
                        } else {
                            double adjusted_pan[EARS_MAX_NUM_CHANNELS]; // panning position for each channel
                            for (long i = 0; i < max_sample; i++) {
                                double pan = pan_sample[i];
                                for (long d = 0; d < source_channelcount; d++)
                                    adjusted_pan[d] = multichannel_pan(pan, pan_mode, source_channelcount, d, multichannel_pan_aperture);
                                for (long c = 0; c < num_out_channels; c++)
                                    for (long d = 0; d < source_channelcount; d++)
                                        dest_sample[i * num_out_channels + c] += source_sample_wk[i * source_channelcount + d] * ears_get_pan_factor(c, num_out_channels, adjusted_pan[d], pan_mode, pan_law) / (compensate_gain_for_multichannel_to_avoid_clipping ? source_channelcount : 1);
                            }
                        }
                    }
                }
                
                ears_buffer_unlocksamples(pan);
            }
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(source_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}





// possibly resamples towards #buf
t_ears_err ears_buffer_multiply_inplace(t_object *ob, t_buffer_obj *buf, t_buffer_obj *factor, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    if (!buf || !factor)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    double sr = ears_buffer_get_sr(ob, buf);
    float *buf_sample = ears_buffer_locksamples(buf);
    
    if (!buf_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);
        t_atom_long	framecount   = buffer_getframecount(buf);
        
        bool resampled = false;
        float *factor_sample = ears_buffer_locksamples(factor);

        if (!factor_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {

            t_atom_long    factor_channelcount = buffer_getchannelcount(factor);
            t_atom_long    factor_framecount   = buffer_getframecount(factor);

            ears_buffer_preprocess_sr_single(ob, sr, factor, &factor_sample, resamplingfiltersize, resamplingmode, &resampled, &factor_framecount);
            
            for (long i = 0; i < framecount; i++) {
                if (i < factor_framecount) {
                    for (long c = 0; c < channelcount; c++) {
                        buf_sample[i*channelcount + c] *= factor_sample[i*factor_channelcount + MIN(c, factor_channelcount - 1)];
                    }
                } else {
                    for (long c = 0; c < channelcount; c++)
                        buf_sample[i*channelcount + c] = 0;
                }
            }
            
            if (resampled)
                bach_freeptr(factor_sample);
            else
                ears_buffer_unlocksamples(factor);
        }
        buffer_setdirty(buf);
        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}


t_ears_err ears_buffer_sum_inplace(t_object *ob, t_buffer_obj *buf, t_buffer_obj *addend, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    if (!buf || !addend)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    bool resampled = false;
    double sr = ears_buffer_get_sr(ob, buf);
    float *buf_sample = ears_buffer_locksamples(buf);
    
    if (!buf_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);
        t_atom_long	framecount   = buffer_getframecount(buf);
        
        float *addend_sample = ears_buffer_locksamples(addend);
        
        if (!addend_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {

            t_atom_long    addend_channelcount = buffer_getchannelcount(buf);
            t_atom_long    addend_framecount   = buffer_getframecount(buf);

            ears_buffer_preprocess_sr_single(ob, sr, addend, &addend_sample, resamplingfiltersize, resamplingmode, &resampled, &addend_framecount);
            
            for (long i = 0; i < framecount; i++) {
                if (i < addend_framecount) {
                    for (long c = 0; c < channelcount; c++) {
                        buf_sample[i*channelcount + c] += addend_sample[i*addend_channelcount + MIN(c, addend_channelcount - 1)];
                    }
                }
            }
            
            if (resampled)
                bach_freeptr(addend_sample);
            else
                ears_buffer_unlocksamples(addend);
        }
        buffer_setdirty(buf);
        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}




t_llll *ears_buffer_to_llll(t_object *ob, t_buffer_obj *buf)
{
    t_llll *out = llll_get();
    
    if (!buf)
        return out;
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return out;
        
    } else {
        
        t_atom_long	channelcount = buffer_getchannelcount(buf);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(buf);			// number of floats long the buffer is for a single channel
        
        t_llll **chan = (t_llll **)bach_newptr(MAX(1, channelcount) * sizeof(t_llll *));
        for (long c = 0; c < channelcount; c++)
            chan[c] = llll_get();
        for (long i = 0; i < framecount; i++)
            for (long c = 0; c < channelcount; c++)
                llll_appenddouble(chan[c], sample[channelcount * i + c]);

        for (long i = 0; i < channelcount; i++)
            llll_appendllll(out, chan[i]);
        bach_freeptr(chan);
    }
    
    ears_buffer_unlocksamples(buf);
    return out;
}


t_atom_long ears_buffer_channel_to_array(t_object *ob, t_buffer_obj *buf, long channel, float **outsamples)
{
    if (!buf)
        return -1;
    
    float *sample = ears_buffer_locksamples(buf);
    t_atom_long    framecount = 0;
    
    if (!sample) {
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return -1;
        
    } else {
        
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        if (!(*outsamples))
            *outsamples = (float *)bach_newptr(framecount * sizeof(float));

        for (long i = 0; i < framecount; i++)
            (*outsamples)[i] = sample[channelcount * i + channel];
    }
    
    ears_buffer_unlocksamples(buf);
    return framecount;
}

t_atom_long ears_buffer_channel_to_double_array(t_object *ob, t_buffer_obj *buf, long channel, double **outsamples)
{
    if (!buf)
        return -1;
    
    float *sample = ears_buffer_locksamples(buf);
    t_atom_long    framecount = 0;
    
    if (!sample) {
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return -1;
        
    } else {
        
        t_atom_long    channelcount = buffer_getchannelcount(buf);        // number of floats in a frame
        framecount   = buffer_getframecount(buf);            // number of floats long the buffer is for a single channel
        
        if (!(*outsamples))
            *outsamples = (double *)bach_newptr(framecount * sizeof(double));
        
        for (long i = 0; i < framecount; i++)
            (*outsamples)[i] = sample[channelcount * i + channel];
    }
    
    ears_buffer_unlocksamples(buf);
    return framecount;
}



t_ears_err ears_buffer_from_llll(t_object *ob, t_buffer_obj *buf, t_llll *ll, char reformat)
{
    if (!buf)
        return EARS_ERR_NO_BUFFER;
    
    // Get max number of samples
    long max_num_samples = 0;
    for (t_llllelem *el = ll->l_head; el; el = el->l_next)
        if (hatom_gettype(&el->l_hatom) == H_LLLL)
            max_num_samples = MAX(max_num_samples, hatom_getllll(&el->l_hatom)->l_size);
    
    // Get number of channels
    long num_channels = ll->l_size;
    
    if (reformat)
        ears_buffer_set_size_and_numchannels(ob, buf, max_num_samples, num_channels);
    
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return EARS_ERR_CANT_READ;
        
    } else {
        
        t_atom_long	channelcount = buffer_getchannelcount(buf);
        t_atom_long	framecount   = buffer_getframecount(buf);
        
        // erasing samples
        memset(sample, 0, framecount * channelcount * sizeof(float));
        
        long c = 0;
        for (t_llllelem *el = ll->l_head; el && c < channelcount; el = el->l_next, c++) {
            if (hatom_gettype(&el->l_hatom) == H_LLLL) {
                long i = 0;
                for (t_llllelem *smp = hatom_getllll(&el->l_hatom)->l_head; smp && i < framecount; smp = smp->l_next, i++) {
                    sample[i*channelcount + c] = hatom_getdouble(&smp->l_hatom);
                }
            }
        }
        
        buffer_setdirty(buf);
    }
    
    ears_buffer_unlocksamples(buf);
    return EARS_ERR_NONE;
}



t_ears_err ears_buffer_from_clicks(t_object *ob, t_buffer_obj *buf, t_llll *onsets_samps, t_llll *gains, t_buffer_obj *impulse)
{
    if (!buf)
        return EARS_ERR_NO_BUFFER;

    if (!onsets_samps)
        return EARS_ERR_GENERIC;
    
    long num_channels = onsets_samps->l_size;
    if (num_channels < 1)
        return EARS_ERR_GENERIC;
    
    t_buffer_obj **chans = (t_buffer_obj **)bach_newptr(MAX(num_channels, 1) * sizeof(t_buffer_obj *));
    
    if (num_channels == 1) {
        chans[0] = buf;
    } else if (num_channels > 1) {
        for (long i = 0; i < num_channels; i++) {
            chans[i] = ears_buffer_make(NULL);
            ears_buffer_copy_format(ob, impulse, chans[i]);
        }
    }
    t_llllelem *onset_el, *gain_el;
    long c = 0;
    for (onset_el = onsets_samps->l_head, gain_el = gains ? gains->l_head : NULL; onset_el;
         onset_el = onset_el->l_next, gain_el = gain_el ? gain_el->l_next : NULL, c++) {
        t_llll *these_onsets = hatom_getllll(&onset_el->l_hatom);
        t_llll *these_gains = gain_el ? hatom_getllll(&gain_el->l_hatom) : NULL;
        if (these_onsets) {
            long num_onsets = these_onsets->l_size;
            t_llll *gains = llll_get();
            long *offset_samps = (long *)bach_newptr(MAX(num_onsets, 1) * sizeof(long));
            t_buffer_obj **sources = (t_buffer_obj **)bach_newptr(MAX(num_onsets, 1) * sizeof(t_buffer_obj *));
            if (these_gains && these_gains->l_head) {
                t_llllelem *el = these_gains->l_head;
                for (long i = 0; i < num_onsets; i++, el = el ? el->l_next : NULL) {
                    llll_appenddouble(gains, el ? hatom_getdouble(&el->l_hatom) : 1.);
                    sources[i] = impulse;
                }
            } else {
                for (long i = 0; i < num_onsets; i++) {
                    llll_appenddouble(gains, 1.);
                    sources[i] = impulse;
                }
            }
            long j = 0;
            for (t_llllelem *el = these_onsets->l_head; el; el = el->l_next) {
                offset_samps[j] = hatom_getdouble(&el->l_hatom);
                j++;
            }
            ears_buffer_mix(ob, sources, num_onsets, chans[c], gains, offset_samps, EARS_NORMALIZE_DONT, k_SLOPE_MAPPING_BACH, EARS_RESAMPLINGPOLICY_DONT, 10, EARS_RESAMPLINGMODE_SINC);
            
            bach_freeptr(offset_samps);
            bach_freeptr(sources);
        }
    }
    
    if (num_channels > 1) {
        ears_buffer_pack(ob, num_channels, chans, buf, EARS_RESAMPLINGPOLICY_DONT, 10, EARS_RESAMPLINGMODE_SINC);
        for (long i = 0; i < num_channels; i++)
            ears_buffer_free(chans[i]);
    }
    
    bach_freeptr(chans);

    return EARS_ERR_NONE;
}



t_pts elem_to_pts(t_llllelem *incoming_el)
{
    t_pts out;
    out.x = out.y = out.slope = 0;
    
    if (hatom_gettype(&incoming_el->l_hatom) == H_LLLL) {
        t_llllelem *elem = hatom_getllll(&incoming_el->l_hatom)->l_head;
        
        if (elem) {
            out.x = hatom_getdouble(&elem->l_hatom);
            elem = elem->l_next;
            if (elem) {
                out.y = hatom_getdouble(&elem->l_hatom);
                elem = elem->l_next;
                if (elem)
                    out.slope = CLAMP(hatom_getdouble(&elem->l_hatom), -1., 1.);
            }
        }
    }
    return out;
}



t_ears_envelope_iterator ears_envelope_iterator_create(t_llll *envelope, double default_val, char use_decibels, e_slope_mapping slopemapping)
{
    t_ears_envelope_iterator eei;
    eei.slopemapping = slopemapping;
    eei.env = envelope;
    eei.default_val = default_val;
    eei.left_el = NULL;
    eei.right_el = envelope ? envelope->l_head : NULL;
    if (eei.right_el)
        eei.left_pts = eei.right_pts = elem_to_pts(eei.right_el);
    eei.use_decibels = use_decibels;
    return eei;
}

t_ears_envelope_iterator ears_envelope_iterator_create_from_llllelem(t_llllelem *envelope, double default_val, char use_decibels, e_slope_mapping slopemapping)
{
    t_ears_envelope_iterator eei;
    if (!envelope) {
        eei.env = NULL; // no envelope, fixed value
        eei.right_el = NULL;
        eei.default_val = default_val;
    } else if (hatom_gettype(&envelope->l_hatom) == H_LLLL) {
        eei.env = hatom_getllll(&envelope->l_hatom);
        eei.right_el = eei.env ? eei.env->l_head : NULL;
        eei.default_val = 0.;
    } else {
        eei.env = NULL; // no envelope, fixed value
        eei.right_el = NULL;
        eei.default_val = hatom_getdouble(&envelope->l_hatom);
    }
    eei.slopemapping = slopemapping;
    eei.use_decibels = use_decibels;
    eei.left_el = NULL;
    if (eei.right_el)
        eei.left_pts = eei.right_pts = elem_to_pts(eei.right_el);
    return eei;
}

void ears_envelope_iterator_reset(t_ears_envelope_iterator *eei)
{
    eei->left_el = NULL;
    eei->right_el = eei->env ? eei->env->l_head : NULL;
    if (eei->right_el)
        eei->left_pts = eei->right_pts = elem_to_pts(eei->right_el);
}

double ears_envelope_iterator_get_max_y(t_ears_envelope_iterator *eei)
{
    double max_y = DBL_MIN;
    for (t_llllelem *el = eei->env->l_head; el; el = el->l_next) {
        t_llll *ll = hatom_getllll(&el->l_hatom);
        if (ll && ll->l_head) {
            double this_y = hatom_getdouble(&ll->l_head->l_next->l_hatom);
            if (this_y > max_y)
                max_y = this_y;
        }
    }
    return max_y;
}

double ears_envelope_iterator_get_min_y(t_ears_envelope_iterator *eei)
{
    double min_y = DBL_MAX;
    for (t_llllelem *el = eei->env->l_head; el; el = el->l_next) {
        t_llll *ll = hatom_getllll(&el->l_hatom);
        if (ll && ll->l_head) {
            double this_y = hatom_getdouble(&ll->l_head->l_next->l_hatom);
            if (this_y < min_y)
                min_y = this_y;
        }
    }
    return min_y;
}


double ears_envelope_iterator_walk_interp(t_ears_envelope_iterator *eei, long sample_num, long tot_num_samples)
{
    if (!eei->env)
        return eei->default_val;
    
    // If the envelope is a simple gain value, return that, there's nowhere to walk!
    if (eei->env->l_depth == 1 && eei->env->l_size == 1)
        return hatom_getdouble(&eei->env->l_head->l_hatom);
    
    // X position is in samples! It has been converted by earsbufobj_llllelem_to_linear_and_samples
    double pos_x = ((double)sample_num); ///(tot_num_samples-1);
    while (eei->right_el && pos_x >= eei->right_pts.x) {
        eei->left_el = eei->right_el;
        eei->right_el = eei->right_el->l_next;
        eei->left_pts = eei->right_pts;
        if (eei->right_el)
            eei->right_pts = elem_to_pts(eei->right_el);
    }
    
    double amp = 0.;
    if (eei->right_el && eei->left_el)
        amp = rescale_with_slope(pos_x, eei->left_pts.x, eei->right_pts.x, eei->left_pts.y, eei->right_pts.y, eei->right_pts.slope, eei->slopemapping);
    else if (eei->left_el)
        amp = eei->left_pts.y;
    else if (eei->right_el)
        amp = eei->right_pts.y;
    
    return eei->use_decibels ? ears_db_to_linear(amp) : amp;
}


t_ears_err ears_buffer_gain_envelope(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, t_llll *env, char use_decibels, e_slope_mapping slopemapping)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            t_ears_envelope_iterator eei = ears_envelope_iterator_create(env, 0., use_decibels, slopemapping);
            for (long i = 0; i < framecount; i++) {
                double factor = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                
                for (long c = 0; c < channelcount; c++) {
                    long idx = channelcount * i + c;
                    dest_sample[idx] = orig_sample[idx] * factor;
                }
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        
        ears_buffer_unlocksamples(source);

    }
    
    return err;
}


t_ears_err ears_buffer_clip_envelope(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, t_llll *thresh, char use_decibels, e_slope_mapping slopemapping)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            t_ears_envelope_iterator eei = ears_envelope_iterator_create(thresh, 0., use_decibels, slopemapping);
            for (long i = 0; i < framecount; i++) {
                double threshold = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                
                for (long c = 0; c < channelcount; c++) {
                    long idx = channelcount * i + c;
                    if (fabs(orig_sample[idx]) <= threshold) {
                        dest_sample[idx] = orig_sample[idx];
                    } else {
                        dest_sample[idx] = (orig_sample[idx] >= 0 ? 1 : -1) * threshold;
                    }
                }
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_overdrive_envelope(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, t_llll *drive, e_slope_mapping slopemapping)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        
        if (source != dest) {
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = (source == dest ? orig_sample : ears_buffer_locksamples(dest));
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            t_ears_envelope_iterator eei = ears_envelope_iterator_create(drive, 0., false, slopemapping);
            for (long i = 0; i < framecount; i++) {
                double this_drive = ears_envelope_iterator_walk_interp(&eei, i, framecount);
                
                for (long c = 0; c < channelcount; c++) {
                    long idx = channelcount * i + c;
                    dest_sample[idx] = ears_overdrive(orig_sample[idx], this_drive);
                }
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}




t_ears_err ears_buffer_normalize(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double linear_amp_level, double mix)
{
    double maxabs = 0;
    t_ears_err err = ears_buffer_get_maxabs(ob, source, &maxabs);
    if (err == EARS_ERR_EMPTY_BUFFER)
        object_warn(ob, EARS_ERROR_BUF_EMPTY_BUFFER);

    if (err != EARS_ERR_NONE)
        return err;
    else if (maxabs == 0) {
        object_error((t_object *)ob, EARS_ERROR_BUF_ZERO_AMP);
        if (source != dest)
            ears_buffer_clone(ob, source, dest);
        return EARS_ERR_ZERO_AMP;
    } else {
        double factor = mix * linear_amp_level/maxabs + (1-mix);
        return ears_buffer_gain(ob, source, dest, factor, false);
    }
}


t_ears_err ears_buffer_normalize_rms(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double linear_amp_level, double mix)
{
    double rms = 0;
    t_ears_err err = ears_buffer_get_rms(ob, source, &rms);
    
    if (err != EARS_ERR_NONE)
        return err;
    if (rms == 0) {
        object_error((t_object *)ob, EARS_ERROR_BUF_ZERO_AMP);
        if (source != dest)
            ears_buffer_clone(ob, source, dest);
        return EARS_ERR_ZERO_AMP;
    } else {
        double factor = mix * linear_amp_level/rms + (1-mix);
        return ears_buffer_gain(ob, source, dest, factor, false);
    }
}







// position ranges from 0 = fade is at 0 factor, to 1 = fade is at 1 factor (original gain)
float ears_get_fade_factor(char in_or_out, e_ears_fade_types fade, double position, double curve, e_slope_mapping slopemapping)
{
    switch (fade) {
        case EARS_FADE_LINEAR:
            return position;
            break;
        case EARS_FADE_SINE:
            return sin(PIOVERTWO * position);
            break;
        case EARS_FADE_CURVE: // could find a faster formula, this is CPU consuming
            CLIP_ASSIGN(curve, -1., 1.);
            return rescale_with_slope(position, 0, 1., 0., 1., curve * in_or_out, slopemapping);
            break;
        case EARS_FADE_SCURVE:  // could find a faster formula, this is CPU consuming
            CLIP_ASSIGN(curve, -1., 1.);
            if (position == 0.5)
                return 0.5;
            else if (position < 0.5)
                return rescale_with_slope(position, 0., 0.5, 0., 0.5, curve * in_or_out, slopemapping);
            else
                return 1. - rescale_with_slope(1. - position, 0., 0.5, 0., 0.5, curve * in_or_out, slopemapping);
            break;
        default:
            return 1.;
            break;
    }
}

float ears_get_fade_in_factor(e_ears_fade_types fade, double position, double curve, e_slope_mapping slopemapping)
{
    return ears_get_fade_factor(1, fade, position, curve, slopemapping);
}

float ears_get_fade_out_factor(e_ears_fade_types fade, double position, double curve, e_slope_mapping slopemapping)
{
    return ears_get_fade_factor(-1, fade, position, curve, slopemapping);
}


t_ears_err ears_buffer_fade(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long fade_in_samples, long fade_out_samples, e_ears_fade_types fade_in_type, e_ears_fade_types fade_out_type, double fade_in_curve, double fade_out_curve, e_slope_mapping slopemapping)
{
    if (source == dest)
        return ears_buffer_fade_inplace(ob, source, fade_in_samples, fade_out_samples, fade_in_type, fade_out_type, fade_in_curve, fade_out_curve, slopemapping);
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);
        t_atom_long	framecount   = buffer_getframecount(source);
        
        long actual_fade_in_samples = CLAMP(fade_in_samples, 0, framecount);
        long actual_fade_out_samples = CLAMP(fade_out_samples, 0, framecount);
        
        ears_buffer_copy_format(ob, source, dest, true); // won't change channels/framecount: that'll be done later on
        ears_buffer_set_size_and_numchannels(ob, dest, framecount, channelcount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        t_atom_long dest_channelcount = buffer_getchannelcount(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            long j, c;

            // copying
            sysmem_copyptr(orig_sample, dest_sample, framecount * dest_channelcount * sizeof(float));
            
            // applying fade in
            for (j = 0; j < actual_fade_in_samples; j++) {
                for (c = 0; c < dest_channelcount; c++)
                    dest_sample[j*dest_channelcount + c] *= ears_get_fade_in_factor(fade_in_type, ((float)j)/fade_in_samples, fade_in_curve, slopemapping);
            }

            // applying fade out
            for (j = framecount - actual_fade_out_samples; j < framecount; j++) {
                for (c = 0; c < dest_channelcount; c++)
                    dest_sample[j*dest_channelcount + c] *= ears_get_fade_out_factor(fade_out_type, (framecount - (float)j)/fade_out_samples, fade_out_curve, slopemapping);
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_fade_ms(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long fade_in_ms, long fade_out_ms, e_ears_fade_types fade_in_type, e_ears_fade_types fade_out_type, double fade_in_curve, double fade_out_curve, e_slope_mapping slopemapping)
{
    if (source == dest)
        return ears_buffer_fade_ms_inplace(ob, source, fade_in_ms, fade_out_ms, fade_in_type, fade_out_type, fade_in_curve, fade_out_curve, slopemapping);

    
    float msr = buffer_getmillisamplerate(source);
    long fade_in_samps = round(fade_in_ms * msr);
    long fade_out_samps = round(fade_out_ms * msr);
    
    return ears_buffer_fade(ob, source, dest, fade_in_samps, fade_out_samps, fade_in_type, fade_out_type, fade_in_curve, fade_out_curve, slopemapping);
}


t_ears_err ears_buffer_fade_inplace(t_object *ob, t_buffer_obj *buf, long fade_in_samples, long fade_out_samples, e_ears_fade_types fade_in_type, e_ears_fade_types fade_out_type, double fade_in_curve, double fade_out_curve, e_slope_mapping slopemapping)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(buf);
        t_atom_long	framecount   = buffer_getframecount(buf);
        
        long actual_fade_in_samples = CLAMP(fade_in_samples, 0, framecount);
        long actual_fade_out_samples = CLAMP(fade_out_samples, 0, framecount);

        long j, c;
        
        // applying fade in
        for (j = 0; j < actual_fade_in_samples; j++) {
            for (c = 0; c < channelcount; c++)
                sample[j*channelcount + c] *= ears_get_fade_in_factor(fade_in_type, ((float)j)/fade_in_samples, fade_in_curve, slopemapping);
        }
        
        // applying fade out
        for (j = framecount - actual_fade_out_samples; j < framecount; j++) {
            for (c = 0; c < channelcount; c++)
                sample[j*channelcount + c] *= ears_get_fade_out_factor(fade_out_type, (framecount - (float)j)/fade_out_samples, fade_out_curve, slopemapping);
        }
        
        buffer_setdirty(buf);
        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}

t_ears_err ears_buffer_fade_ms_inplace(t_object *ob, t_buffer_obj *buf, long fade_in_ms, long fade_out_ms, e_ears_fade_types fade_in_type, e_ears_fade_types fade_out_type, double fade_in_curve, double fade_out_curve, e_slope_mapping slopemapping)
{
    float msr = buffer_getmillisamplerate(buf);
    long fade_in_samps = round(fade_in_ms * msr);
    long fade_out_samps = round(fade_out_ms * msr);
    
    return ears_buffer_fade_inplace(ob, buf, fade_in_samps, fade_out_samps, fade_in_type, fade_out_type, fade_in_curve, fade_out_curve, slopemapping);
}


void ears_buffer_preprocess_sr_policies(t_object *ob, t_buffer_obj **source, long num_sources, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode, double *sr, bool *resampled, float **samples, long *num_samples, bool *must_free_samples, long *source_first_unique_idx)
{
    if (!ears_buffers_have_the_same_sr(ob, num_sources, source) && resamplingpolicy != EARS_RESAMPLINGPOLICY_DONT) {
        *resampled = true;
        *sr = ears_buffers_get_collective_sr(ob, num_sources, source, resamplingpolicy);
        for (long i = 0; i < num_sources; i++) {
            if (!samples[i])
                continue;
            
            double this_sr = ears_buffer_get_sr(ob, source[i]);
            if (this_sr != *sr && (!source_first_unique_idx || source_first_unique_idx[i] == i)) {
                // must resample
                long num_channels = ears_buffer_get_numchannels(ob, source[i]);
                double factor = (*sr/this_sr);
                long num_in_frames = ears_buffer_get_size_samps(ob, source[i]);
                long num_out_frames = ceil(num_in_frames * factor);
                float *new_samples = (float *)bach_newptr(num_out_frames * num_channels * sizeof(float));
                
                ears_resample(resamplingmode, samples[i], num_in_frames, &new_samples, num_out_frames, factor, num_channels, this_sr/2., this_sr, resamplingfiltersize);
                
                ears_buffer_unlocksamples(source[i]);
                samples[i] = new_samples;
                num_samples[i] = num_out_frames;
                must_free_samples[i] = true;
                
                if (source_first_unique_idx) {
                    for (long j = i+1; j < num_sources; j++) {
                        if (source_first_unique_idx[j] == i) {
                            samples[j] = samples[i];
                            num_samples[j] = num_samples[i];
                        }
                    }
                }
            }
        }
    }
}

void fill_source_first_unique_idx(t_buffer_obj **source, long num_sources, long *source_first_unique_idx)
{
    for (long i = 0; i < num_sources; i++)
        source_first_unique_idx[i] = i;
    for (long i = 0; i < num_sources; i++) {
        if (source_first_unique_idx[i] != i)
            continue;
        for (long j = i+1; j < num_sources; j++)
            if (source[j] == source[i])
                source_first_unique_idx[j] = i;
    }
}



t_ears_err ears_buffer_mix(t_object *ob, t_buffer_obj **source, long num_sources, t_buffer_obj *dest, t_llll *gains, long *offset_samps,
                           e_ears_normalization_modes normalization_mode, e_slope_mapping slopemapping,
                           e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (num_sources == 0) {
        ears_buffer_set_size_samps(ob, dest, 0);
        return EARS_ERR_NONE;
    }
    
    bool resampled = false;
    long i, num_locked = 0;
    float **samples = (float **)bach_newptr(num_sources * sizeof(float *));
    bool *must_free_samples = (bool *)bach_newptrclear(num_sources * sizeof(bool));
    long *num_samples = (long *)bach_newptr(num_sources * sizeof(long));
    long *num_channels = (long *)bach_newptr(num_sources * sizeof(long));
    long *source_first_unique_idx = (long *)bach_newptrclear(num_sources * sizeof(long));

    fill_source_first_unique_idx(source, num_sources, source_first_unique_idx);

    t_atom_long	channelcount = 0;
    double total_length = 0;
    float *dest_sample = NULL;
    double sr = ears_buffer_get_sr(ob, source[0]);
    
    channelcount = buffer_getchannelcount(source[0]);
    for (i = 0, num_locked = 0; i < num_sources; i++, num_locked++) {
        if (source_first_unique_idx[i] == i) {
            samples[i] = ears_buffer_locksamples(source[i]);
            if (!samples[i]) {
                err = EARS_ERR_CANT_READ;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
//                goto end;
            }
        } else {
            samples[i] = samples[source_first_unique_idx[i]];
        }
    }
    
    
    for (i = 0; i < num_sources; i++) {
        num_samples[i] = samples[i] ? buffer_getframecount(source[i]) : 0;
        num_channels[i] = samples[i] ? buffer_getchannelcount(source[i]) : 1;
        if (num_channels[i] > channelcount)
            channelcount = num_channels[i]; // using as number of channels the maximum number of channels in the input data
    }

    ears_buffer_preprocess_sr_policies(ob, source, num_sources, resamplingpolicy, resamplingfiltersize, resamplingmode, &sr, &resampled, samples, num_samples, must_free_samples, source_first_unique_idx);
    
    ears_buffer_set_sr(ob, dest, sr);
    
    // Getting max num samples
    long st = 0;
    total_length = -1;
    while (st < num_sources) {
        if (samples[st]) {
            total_length = num_samples[st] + offset_samps[st];
            break;
        } else {
            st++;
        }
    }
    
    if (total_length < 0) {
        // hard error: there's no buffer to mix!
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, "Cannot read any of the buffers");
        goto end;
    }
    
    for (i = 1; i < num_sources; i++)
        if (samples[i]) {
            if (num_samples[i] + offset_samps[i] > total_length)
                total_length = num_samples[i] + offset_samps[i];
        }
    
    ears_buffer_set_size_and_numchannels(ob, dest, total_length, channelcount);

    dest_sample = ears_buffer_locksamples(dest);
    if (!dest_sample) {
        err = EARS_ERR_CANT_WRITE;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
    } else {
        // erasing samples
        memset(dest_sample, 0, total_length * channelcount * sizeof(float));
        
        // writing samples
        long j, c;
        t_llllelem *elem;
        for (i = 0, elem = gains ? gains->l_head : NULL; i < num_sources; i++, elem = (elem && elem->l_next) ? elem->l_next : elem) {
            
            if (!samples[i])
                continue;
            
            long this_onset_samps = offset_samps[i] > 0 ? offset_samps[i] : 0;
            
            t_ears_envelope_iterator eei = ears_envelope_iterator_create_from_llllelem(elem, 1., false, slopemapping);
            for (j = 0; j < num_samples[i]; j++) {
                double this_gain = ears_envelope_iterator_walk_interp(&eei, j, num_samples[i]);
                for (c = 0; c < num_channels[i] && c < channelcount; c++)
                    dest_sample[(j + this_onset_samps) * channelcount + c] += samples[i][j * num_channels[i] + c] * this_gain;
            }
        }
        
        buffer_setdirty(dest);
        ears_buffer_unlocksamples(dest);
    }
    
end:
    for (i = 0; i < num_locked; i++) {
        if (must_free_samples[i] && samples[i])
            bach_freeptr(samples[i]);
        else if (source_first_unique_idx[i] == i)
            ears_buffer_unlocksamples(source[i]);
    }
    
    bach_freeptr(source_first_unique_idx);
    bach_freeptr(must_free_samples);
    bach_freeptr(samples);
    bach_freeptr(num_samples);
    bach_freeptr(num_channels);

    // Finally, we normalize if needed
    switch (normalization_mode) {
        case EARS_NORMALIZE_DO:
            ears_buffer_normalize_inplace(ob, dest, 1.);
            break;
            
        case EARS_NORMALIZE_OVERLOAD_PROTECTION_ONLY:
        {
            double maxabs = 0.;
            t_ears_err err = ears_buffer_get_maxabs(ob, dest, &maxabs);
            if (err == EARS_ERR_EMPTY_BUFFER)
                object_warn(ob, EARS_ERROR_BUF_EMPTY_BUFFER);
            if (err == EARS_ERR_NONE && maxabs > 1.) {
                object_warn(ob, "Mixdown peak is %.3f, output buffer will be normalized due to overload protection.", maxabs);
                ears_buffer_normalize_inplace(ob, dest, 1.);
            }
        }
            break;
            
        case EARS_NORMALIZE_DONT:
        default:
            break;
    }
    
    
    return err;
}


t_ears_err ears_buffer_mix_subsampleprec(t_object *ob, t_buffer_obj **source, long num_sources, t_buffer_obj *dest,
                                          t_llll *gains, double *offset_samps,
                                          e_ears_normalization_modes normalization_mode, e_slope_mapping slopemapping,
                                          e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (num_sources == 0) {
        ears_buffer_set_size_samps(ob, dest, 0);
        return EARS_ERR_NONE;
    }
    
    bool resampled = false;
    long i, num_locked = 0;
    float **samples = (float **)bach_newptr(num_sources * sizeof(float *));
    bool *must_free_samples = (bool *)bach_newptrclear(num_sources * sizeof(bool));
    long *num_samples = (long *)bach_newptr(num_sources * sizeof(long));
    long *num_channels = (long *)bach_newptr(num_sources * sizeof(long));
    long *source_first_unique_idx = (long *)bach_newptrclear(num_sources * sizeof(long));
    
    fill_source_first_unique_idx(source, num_sources, source_first_unique_idx);
    
    t_atom_long    channelcount = 0;
    long total_length = 0;
    float *dest_sample = NULL;
    double sr = ears_buffer_get_sr(ob, source[0]);
    
    channelcount = buffer_getchannelcount(source[0]);        // number of floats in a frame
    for (i = 0, num_locked = 0; i < num_sources; i++, num_locked++) {
        if (source_first_unique_idx[i] == i) {
            samples[i] = ears_buffer_locksamples(source[i]);
            if (!samples[i]) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
                goto end;
            }
        } else {
            samples[i] = samples[source_first_unique_idx[i]];
        }
    }
    
    
    for (i = 0; i < num_sources; i++) {
        num_samples[i] = buffer_getframecount(source[i]);
        num_channels[i] = buffer_getchannelcount(source[i]);
    }
    
    ears_buffer_preprocess_sr_policies(ob, source, num_sources, resamplingpolicy, resamplingfiltersize, resamplingmode, &sr, &resampled, samples, num_samples, must_free_samples, source_first_unique_idx);
    
    ears_buffer_set_sr(ob, dest, sr);
    
    // Getting max num samples
    total_length = num_samples[0] + (long)ceil(offset_samps[0]);
    for (i = 1; i < num_sources; i++)
        if (num_samples[i] + (long)ceil(offset_samps[i]) > total_length)
            total_length = num_samples[i] + (long)ceil(offset_samps[i]);
    
    ears_buffer_set_size_and_numchannels(ob, dest, total_length, channelcount);
    
    dest_sample = ears_buffer_locksamples(dest);
    if (!dest_sample) {
        err = EARS_ERR_CANT_WRITE;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
    } else {
        // erasing samples
        memset(dest_sample, 0, total_length * channelcount * sizeof(float));
        
        // writing samples
        long j, c;
        t_llllelem *elem;
        for (i = 0, elem = gains ? gains->l_head : NULL; i < num_sources; i++, elem = (elem && elem->l_next) ? elem->l_next : elem) {
            
            double this_onset_samps = offset_samps[i] > 0 ? offset_samps[i] : 0;
            t_ears_envelope_iterator eei = ears_envelope_iterator_create_from_llllelem(elem, 1., false, slopemapping);

            if (fmod(this_onset_samps, 1.) == 0) {
                for (j = 0; j < num_samples[i]; j++) {
                    double this_gain = ears_envelope_iterator_walk_interp(&eei, j, num_samples[i]);
                    for (c = 0; c < num_channels[i] && c < channelcount; c++)
                        dest_sample[(j + (long)this_onset_samps) * channelcount + c] += samples[i][j * num_channels[i] + c] * this_gain;
                }
            } else {
                long this_onset_samps_floor = (long)floor(this_onset_samps);
                double diff = this_onset_samps - this_onset_samps_floor;
                long lower_limit = MAX(-resamplingfiltersize-1, 0);
                long upper_limit = MIN(num_samples[i] + resamplingfiltersize+1, total_length - this_onset_samps_floor);
                for (j = lower_limit; j < upper_limit; j++) {
                    double this_gain = ears_envelope_iterator_walk_interp(&eei, j, num_samples[i]);
                    for (c = 0; c < num_channels[i] && c < channelcount; c++) {
//                        double s = samples[i][j * num_channels[i] + c];
                        double s = ears_interp_sinc(&(samples[i][c]), num_samples[i], j - diff, resamplingfiltersize, num_channels[i]);
                        dest_sample[(j + this_onset_samps_floor) * channelcount + c] += s * this_gain;
                    }
                }
            }
        }
        
        buffer_setdirty(dest);
        ears_buffer_unlocksamples(dest);
    }
    
end:
    for (i = 0; i < num_locked; i++) {
        if (must_free_samples[i])
            bach_freeptr(samples[i]);
        else if (source_first_unique_idx[i] == i)
            ears_buffer_unlocksamples(source[i]);
    }
    
    bach_freeptr(source_first_unique_idx);
    bach_freeptr(must_free_samples);
    bach_freeptr(samples);
    bach_freeptr(num_samples);
    bach_freeptr(num_channels);
    
    // Finally, we normalize if needed
    switch (normalization_mode) {
        case EARS_NORMALIZE_DO:
            ears_buffer_normalize_inplace(ob, dest, 1.);
            break;
            
        case EARS_NORMALIZE_OVERLOAD_PROTECTION_ONLY:
        {
            double maxabs = 0.;
            t_ears_err err = ears_buffer_get_maxabs(ob, dest, &maxabs);
            if (err == EARS_ERR_EMPTY_BUFFER)
                object_warn(ob, EARS_ERROR_BUF_EMPTY_BUFFER);
            if (err == EARS_ERR_NONE && maxabs > 1.) {
                object_warn(ob, "Mixdown peak is %.3f, output buffer will be normalized due to overload protection.", maxabs);
                ears_buffer_normalize_inplace(ob, dest, 1.);
            }
        }
            break;
            
        case EARS_NORMALIZE_DONT:
        default:
            break;
    }
    
    
    return err;
}


t_ears_err ears_buffer_mix_from_llll_do(t_object *ob, t_llll *sources_ll, t_buffer_obj *dest, t_llll *gains, t_llll *offset_samps_ll, e_ears_normalization_modes normalization_mode, e_slope_mapping slopemapping, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    long num_sources = sources_ll->l_size;
    
    if (num_sources == 0)
        return ears_buffer_pack(ob, 0, NULL, dest, resamplingpolicy, resamplingfiltersize, resamplingmode);
    else {
        long i = 0;
        long *offset_samps = (long *)bach_newptrclear(num_sources * sizeof(long));
        t_buffer_obj **sources = (t_buffer_obj **)bach_newptr(num_sources * sizeof(t_buffer_obj *));

        for (t_llllelem *el = sources_ll->l_head; el; el = el->l_next, i++)
            sources[i] = (t_buffer_obj *)hatom_getobj(&el->l_hatom);
        
        i = 0;
        for (t_llllelem *el = offset_samps_ll->l_head; el; el = el->l_next, i++)
            offset_samps[i] = hatom_getlong(&el->l_hatom);

        t_max_err err = ears_buffer_mix(ob, sources, num_sources, dest, gains, offset_samps, normalization_mode, slopemapping, resamplingpolicy, resamplingfiltersize, resamplingmode);
        bach_freeptr(sources);
        bach_freeptr(offset_samps);
        return err;
    }
}

t_ears_err ears_buffer_mix_from_llll(t_object *ob, t_llll *sources_ll, t_buffer_obj *dest, t_llll *gains, t_llll *offset_samps_ll, e_ears_normalization_modes normalization_mode, e_slope_mapping slopemapping, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (sources_ll->l_depth == 2 && gains->l_depth == 2 && offset_samps_ll->l_depth == 2) {
        // Special case: if lists have a level of parentheses, their elements are bounced in separate channels  i.e., "voice-wise" mixing, then all voices are kept separate
        long numvoices = sources_ll->l_size;
        if (gains->l_size != numvoices || offset_samps_ll->l_size != numvoices) {
            err = EARS_ERR_GENERIC;
            object_error((t_object *)ob, "Lists have different lengths!");
            return err;
        }
        if (numvoices <= 0) {
            err = EARS_ERR_GENERIC;
            object_error((t_object *)ob, "Lists have zero length!");
            return err;
        }
        t_buffer_obj **voicebuf = (t_buffer_obj **)bach_newptr(numvoices * sizeof(t_buffer_obj *));
        for (long i = 0; i < numvoices; i++) {
            voicebuf[i] = ears_buffer_make(NULL);
        }
        t_llllelem *sources_el = sources_ll->l_head, *gain_el = gains->l_head, *offset_samps_el = offset_samps_ll->l_head;
        long i = 0;
        for (; sources_el && gain_el && offset_samps_el; sources_el = sources_el->l_next, gain_el = gain_el->l_next, offset_samps_el = offset_samps_el->l_next, i++) {
            if (hatom_gettype(&sources_el->l_hatom) == H_LLLL && hatom_gettype(&gain_el->l_hatom) == H_LLLL && hatom_gettype(&offset_samps_el->l_hatom) == H_LLLL) {
                t_ears_err this_err = ears_buffer_mix_from_llll_do(ob, hatom_getllll(&sources_el->l_hatom), voicebuf[i], hatom_getllll(&gain_el->l_hatom), hatom_getllll(&offset_samps_el->l_hatom), normalization_mode, slopemapping, resamplingpolicy, resamplingfiltersize, resamplingmode);
                
                if (err == EARS_ERR_NONE && this_err != err) {
                    err = this_err;
                }
            }
        }
        ears_buffer_pack(ob, numvoices, voicebuf, dest, resamplingpolicy, resamplingfiltersize, resamplingmode);
        for (long i = 0; i < numvoices; i++) {
            ears_buffer_free(voicebuf[i]);
        }
        bach_freeptr(voicebuf);

    } else {
        // standard easy case
        
        err = ears_buffer_mix_from_llll_do(ob, sources_ll, dest, gains, offset_samps_ll, normalization_mode, slopemapping, resamplingpolicy, resamplingfiltersize, resamplingmode);
    }
    return err;
}


t_ears_err ears_buffer_join(t_object *ob, t_buffer_obj **source, long num_sources, t_buffer_obj *dest,
                              long *xfade_samples, char also_fade_boundaries,
                              e_ears_fade_types fade_type, double fade_curve, e_slope_mapping slopemapping,
                              e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;

    if (num_sources == 0) {
        ears_buffer_set_size_samps(ob, dest, 0);
        return EARS_ERR_NONE;
    } else if (num_sources == 1) {
        if (also_fade_boundaries)
            return ears_buffer_fade(ob, source[0], dest, xfade_samples && xfade_samples[0] > 0 ? xfade_samples[0] : 0, xfade_samples && xfade_samples[0] > 0 ? xfade_samples[0] : 0, fade_type, fade_type, fade_curve, fade_curve, slopemapping);
        else
            return ears_buffer_clone(ob, source[0], dest);
    }
    
    // here we have at least 2 buffers to concatenate
    
    bool resampled = false;
    long i, num_locked = 0;
    float **samples = (float **)bach_newptr(num_sources * sizeof(float *));
    bool *must_free_samples = (bool *)bach_newptrclear(num_sources * sizeof(bool));
    long *num_samples = (long *)bach_newptr(num_sources * sizeof(long));
    long *num_channels = (long *)bach_newptr(num_sources * sizeof(long));

    // position in samples of beginning, end, end of fade in and beginning of fade out, for each buffer
    long *sample_start = (long *)bach_newptr(num_sources * sizeof(long));
    long *sample_fadein_end = (long *)bach_newptr(num_sources * sizeof(long)); // this is the FIRST sample of the non-fade region
    long *sample_fadeout_start = (long *)bach_newptr(num_sources * sizeof(long));
    long *sample_end = (long *)bach_newptr(num_sources * sizeof(long)); // this is the FIRST sample of the region AFTER the buffer,
                                                                        // so that sample_end-sample_start = actual samples in the buffer
    long *source_first_unique_idx = (long *)bach_newptrclear(num_sources * sizeof(long));
    
    fill_source_first_unique_idx(source, num_sources, source_first_unique_idx);

    t_atom_long	channelcount = 0;
    double total_length = 0;
    float *dest_sample = NULL;
    double sr = ears_buffer_get_sr(ob, source[0]);
    
    for (i = 0, num_locked = 0; i < num_sources; i++, num_locked++) {
        if (source_first_unique_idx[i] == i) {
            samples[i] = ears_buffer_locksamples(source[i]);
            if (!samples[i]) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
                goto end;
            }
        } else {
            samples[i] = samples[source_first_unique_idx[i]];
        }
    }
    
    for (i = 0; i < num_sources; i++) {
        num_samples[i] = buffer_getframecount(source[i]);
        num_channels[i] = buffer_getchannelcount(source[i]);
    }
    
    ears_buffer_preprocess_sr_policies(ob, source, num_sources, resamplingpolicy, resamplingfiltersize, resamplingmode, &sr, &resampled, samples, num_samples, must_free_samples, source_first_unique_idx);
    
    ears_buffer_set_sr(ob, dest, sr);

    
    // Calculating total length in samples of dest buffer
    channelcount = buffer_getchannelcount(source[0]);		// number of floats in a frame
    for (i = 0; i < num_sources; i++) {
        if (i == 0) {
            sample_start[i] = 0;
            sample_end[i] = sample_start[i] + num_samples[i];
            sample_fadein_end[i] = also_fade_boundaries ? sample_start[i] + MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2) : 0;
            sample_fadeout_start[i] = sample_end[i] - MIN(MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2), num_samples[i+1]/2);
        } else if (i == num_sources - 1) {
            sample_start[i] = sample_fadeout_start[i-1];
            sample_end[i] = sample_start[i] + num_samples[i];
            sample_fadein_end[i] = sample_start[i] + MIN(MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2), num_samples[i-1]/2);
            sample_fadeout_start[i] = also_fade_boundaries ? sample_end[i] - MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2) : sample_end[i];
        } else {
            sample_start[i] = sample_fadeout_start[i-1];
            sample_end[i] = sample_start[i] + num_samples[i];
            sample_fadein_end[i] = sample_start[i] + MIN(MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2), num_samples[i-1]/2);
            sample_fadeout_start[i] = sample_end[i] - MIN(MIN(xfade_samples ? xfade_samples[i]/2 : 0, num_samples[i]/2), num_samples[i+1]/2);
        }
    }

    total_length = sample_end[num_sources-1]; // global length
//    ears_buffer_set_size_samps(ob, dest, total_length);
    ears_buffer_set_size_and_numchannels(ob, dest, total_length, channelcount);
    
    dest_sample = ears_buffer_locksamples(dest);
    if (!dest_sample) {
        err = EARS_ERR_CANT_WRITE;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
    } else {
        // erasing samples
        memset(dest_sample, 0, total_length * channelcount * sizeof(float));
        
        // writing samples
        long j, c;
        for (i = 0; i < num_sources; i++) {
            
            // fade in
            for (j = sample_start[i]; j < sample_fadein_end[i]; j++) {
                long l = j - sample_start[i];
                for (c = 0; c < channelcount && c < num_channels[i] && l < num_samples[i]; c++) {
                    dest_sample[j * channelcount + c] += samples[i][l * num_channels[i] + c] * ears_get_fade_in_factor(fade_type, ((float)l)/(sample_fadein_end[i] - sample_start[i]), fade_curve, slopemapping);
                }
            }
            
            
            // "sustain"
            for ( ; j < MIN(sample_end[i], sample_fadeout_start[i]); j++) {
                // copying samples
                // TO DO: can be done via sysmem_copyptr()
                long l = j - sample_start[i];
                for (c = 0; c < channelcount && c < num_channels[i] && l < num_samples[i]; c++) {
                    dest_sample[j * channelcount + c] += samples[i][l * num_channels[i] + c];
                }
            }
            
            // fade out
            for ( ; j < sample_end[i]; j++) {
                long l = j - sample_start[i];
                for (c = 0; c < channelcount && c < num_channels[i] && l < num_samples[i]; c++) {
                    dest_sample[j * channelcount + c] += samples[i][l * num_channels[i] + c] * ears_get_fade_out_factor(fade_type, (sample_end[i] - ((float)j))/(sample_end[i] - sample_fadeout_start[i]), fade_curve, slopemapping);
                }
            }
        }
        
        buffer_setdirty(dest);
        ears_buffer_unlocksamples(dest);
    }
    
end:
    for (i = 0; i < num_locked; i++) {
        if (must_free_samples[i])
            bach_freeptr(samples[i]);
        else if (source_first_unique_idx[i] == i)
            ears_buffer_unlocksamples(source[i]);
    }
    
    bach_freeptr(source_first_unique_idx);
    bach_freeptr(samples);
    bach_freeptr(must_free_samples);
    bach_freeptr(num_samples);
    bach_freeptr(num_channels);
    bach_freeptr(sample_fadein_end);
    bach_freeptr(sample_end);
    
    return err;
}




// take an existing buffer and mixes another one over it
t_ears_err ears_buffer_assemble_once(t_object *ob, t_buffer_obj *basebuffer, t_buffer_obj *newbuffer, t_llll *gains, long offset_samps, e_slope_mapping slopemapping, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode, long *basebuffer_numframes, long *basebuffer_allocatedframes, long channel_offset)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!basebuffer) {
        return EARS_ERR_NO_BUFFER;
    }
    
    if (!newbuffer) {
        return EARS_ERR_NO_BUFFER;
    }
    
    char must_free = false;
    t_atom_long channelcount = ears_buffer_get_numchannels(ob, basebuffer);
    long numsamps = *basebuffer_numframes; //ears_buffer_get_size_samps(ob, basebuffer);
    double sr = ears_buffer_get_sr(ob, basebuffer);
    
    t_atom_long new_channelcount = ears_buffer_get_numchannels(ob, newbuffer);
    long new_numsamps = ears_buffer_get_size_samps(ob, newbuffer);
    double new_sr = ears_buffer_get_sr(ob, newbuffer);

    float *base_sample, *new_sample;
    
    new_sample = ears_buffer_locksamples(newbuffer);
    
    if (new_sr != sr) {
        // must resample!
        double factor = (sr/new_sr);
        long num_in_frames = new_numsamps;
        long num_out_frames = ceil(num_in_frames * factor);
        float *resampled_samples = (float *)bach_newptr(num_out_frames * new_channelcount * sizeof(float));
        ears_resample(resamplingmode, new_sample, num_in_frames, &resampled_samples, num_out_frames, factor, new_channelcount, new_sr/2., new_sr, resamplingfiltersize);
        ears_buffer_unlocksamples(newbuffer);
        new_sample = resampled_samples;
        must_free = true;
    }
    
    // Getting max num samples
    long total_length = MAX(numsamps, new_numsamps + offset_samps);
    
    if (total_length > *basebuffer_allocatedframes) {
        long step = EARS_BUFFER_ASSEMBLE_ALLOCATION_STEP_SEC * sr;
        while (total_length > *basebuffer_allocatedframes)
            (*basebuffer_allocatedframes) += step;
        
        ears_buffer_set_size_samps_preserve(ob, basebuffer, *basebuffer_allocatedframes);
    }
    *basebuffer_numframes = total_length;
    
    base_sample = ears_buffer_locksamples(basebuffer);
    if (!base_sample) {
        err = EARS_ERR_CANT_WRITE;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
    } else {
        // writing samples
        long j, c;
        t_llllelem *elem = gains ? gains->l_head : NULL;
        long this_onset_samps = offset_samps > 0 ? offset_samps : 0;
        
        t_ears_envelope_iterator eei = ears_envelope_iterator_create_from_llllelem(elem, 1., false, slopemapping);
        for (j = 0; j < new_numsamps; j++) {
            double this_gain = ears_envelope_iterator_walk_interp(&eei, j, new_numsamps);
//            for (c = 0; c < new_channelcount && c < channelcount; c++) {
            for (c = channel_offset; c < new_channelcount + channel_offset && c < channelcount; c++) {
                base_sample[(j + this_onset_samps) * channelcount + c] += new_sample[j * new_channelcount + c] * this_gain;
            }
        }
        
        buffer_setdirty(basebuffer);
        ears_buffer_unlocksamples(basebuffer);
    }
    
//end:
    if (must_free)
        bach_freeptr(new_sample);
    else
        ears_buffer_unlocksamples(newbuffer);
    

    return err;
}

t_ears_err ears_buffer_assemble_close(t_object *ob, t_buffer_obj *basebuffer, e_ears_normalization_modes normalization_mode, long length_samps)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!basebuffer)
        return EARS_ERR_NO_BUFFER;
    
    if (length_samps < 0)
        return EARS_ERR_GENERIC;
    
    // Finally, we normalize if needed
    switch (normalization_mode) {
        case EARS_NORMALIZE_DO:
            ears_buffer_normalize_inplace(ob, basebuffer, 1.);
            break;
            
        case EARS_NORMALIZE_OVERLOAD_PROTECTION_ONLY:
        {
            double maxabs = 0.;
            t_ears_err err = ears_buffer_get_maxabs(ob, basebuffer, &maxabs);
            if (err == EARS_ERR_EMPTY_BUFFER)
                object_warn(ob, EARS_ERROR_BUF_EMPTY_BUFFER);
            if (err == EARS_ERR_NONE && maxabs > 1.) {
                object_warn(ob, "Mixdown peak is %.3f, output buffer will be normalized due to overload protection.", maxabs);
                ears_buffer_normalize_inplace(ob, basebuffer, 1.);
            }
        }
            break;
            
        case EARS_NORMALIZE_DONT:
        default:
            break;
    }
    
    // and crop the result
    ears_buffer_set_size_samps_preserve(ob, basebuffer, length_samps);

    return err;
}



t_symbol *default_filepath2buffername(t_symbol *filepath, long buffer_index)
{
    char temp[MAX_PATH_CHARS * 2];
    snprintf_zero(temp, MAX_PATH_CHARS * 2, "%s_%ld_earsbuf", filepath->s_name, buffer_index);
    return gensym(temp);
}

t_symbol *default_synth2buffername(long buffer_index)
{
    char temp[MAX_PATH_CHARS * 2];
    snprintf_zero(temp, MAX_PATH_CHARS * 2, "synth_%ld_earsbuf", buffer_index);
    return gensym(temp);
}

t_ears_err ears_buffer_from_buffer(t_object *ob, t_buffer_obj **dest, t_symbol *buffername, double start_ms, double end_ms, long buffer_idx)
{
    t_symbol *name = default_filepath2buffername(buffername, buffer_idx);
    *dest = ears_buffer_make(name);
    
    t_ears_err this_err = ears_buffer_clone(ob, ears_buffer_get_object(buffername), *dest);
    
    if (start_ms > 0 || end_ms >= 0)
        ears_buffer_crop_ms(ob, *dest, *dest, start_ms, end_ms);
    return this_err;
}

// This is not used by the [ears.read] object, but rather from other objects.
// The <dest> buffers are meant to be used and freed.
t_ears_err ears_buffer_from_file(t_object *ob, t_buffer_obj **dest, t_symbol *file, double start_ms, double end_ms, long buffer_idx)
{
    t_ears_err err = EARS_ERR_NONE;
    t_symbol *filepath = ears_ezlocate_file(file, NULL);
    
    if (filepath) {
        // creating a buffer object!
        
        t_symbol *name = default_filepath2buffername(filepath, buffer_idx);
        *dest = ears_buffer_make(name);
        if (!*dest) {
            err = EARS_ERR_GENERIC;
        } else {
            
#ifdef EARS_MP3_READ_SUPPORT
            if (ears_symbol_ends_with(filepath, ".mp3", true)) {
                err = ears_buffer_read_handle_mp3(ob, filepath->s_name, start_ms, end_ms, *dest, EARS_TIMEUNIT_MS);
            } else {
#endif
                // trying to load file into input buffer
                t_atom a;
                atom_setsym(&a, filepath);
                typedmess(*dest, gensym("importreplace"), 1, &a);
                
                // possibly cropping to given portions
                if (start_ms > 0 || end_ms >= 0) {
                    ears_buffer_crop_ms_inplace(ob, *dest, start_ms, end_ms);
                }
                
#ifdef EARS_MP3_READ_SUPPORT
            }
#endif
        }
        
    } else {
        // can't locate file!
        err = EARS_ERR_NO_FILE;
        object_error(ob, EARS_ERROR_BUF_NO_FILE_NAMED, filepath ? filepath->s_name : (file ? file->s_name : "???"));
        
        *dest = ears_buffer_make(NULL);
        ears_buffer_setempty(ob, *dest, 1);

    }
    
    return err;
}

// DEFINITELY NOT THE QUICKEST SYNTH ;-)
// No antialiasing happening here; this should be done later, if one wants it
double ears_synth_calc(double phase, e_ears_synthmode mode, float *wavetable, long wavetable_length, long resampling_filter_width)
{
    switch (mode) {
        case EARS_SYNTHMODE_SINUSOIDS:
            return sin(phase);
            break;

        case EARS_SYNTHMODE_TRIANGULAR:
            phase = positive_fmod(phase, TWOPI);
            return phase < PIOVERTWO ? phase/PIOVERTWO : (phase < 3*PIOVERTWO ? 2 - phase/PIOVERTWO : phase/PIOVERTWO-4);
            break;

        case EARS_SYNTHMODE_RECTANGULAR:
            phase = positive_fmod(phase, TWOPI);
            return phase > PI ? -1 : 1;
            break;

        case EARS_SYNTHMODE_SAWTOOTH:
            phase = positive_fmod(phase, TWOPI);
            return 2 * phase/TWOPI - 1;
            break;

        case EARS_SYNTHMODE_WAVETABLE:
        {
            
            phase = positive_fmod(phase, TWOPI);
            double idx = wavetable_length * (phase/TWOPI);
            if (false) { // LINEAR INTERPOLATION
                long idx_floor = floor(idx);
                long idx_ceil = idx_floor + 1;
                double diff = idx - idx_floor;
                if (idx_floor >= wavetable_length) idx_floor -= wavetable_length;
                if (idx_ceil >= wavetable_length) idx_ceil -= wavetable_length;
                return (1-diff) * wavetable[idx_floor] + diff * wavetable[idx_ceil]; // linear interpolation
            } else {
                return ears_interp_circular_sinc(wavetable, wavetable_length, idx, resampling_filter_width);
            }
            
        }
            break;

        default:
            return 0;
            break;
    }
}


t_ears_err ears_buffer_synth_from_duration_line(t_object *e_ob, t_buffer_obj **dest,
                                                e_ears_synthmode mode, float *wavetable, long wavetable_length,
                                                double midicents, double duration_ms, double velocity, t_llll *breakpoints,
                                                e_ears_veltoamp_modes veltoamp_mode, double amp_vel_min, double amp_vel_max,
                                                double middleAtuning, double sr, long buffer_idx, e_slope_mapping slopemapping,
                                                long oversampling, long resamplingfiltersize)
{
    if (mode == EARS_SYNTHMODE_SINUSOIDS)
        oversampling = 1; // no need for oversampling if we just use sinusoids, as we will not filter for antialiasing

    t_ears_err err = EARS_ERR_NONE;
    double sr_os = sr * oversampling;
    long duration_samps = (long)ceil(duration_ms * (sr_os/1000.));
    t_symbol *name = default_synth2buffername(buffer_idx);
    *dest = ears_buffer_make(name);
    
    ears_buffer_set_size_and_numchannels(e_ob, *dest, duration_samps, 1);
    ears_buffer_set_sr(e_ob, *dest, sr_os);

    float *sample = ears_buffer_locksamples(*dest);

    if (mode == EARS_SYNTHMODE_WAVETABLE && (!wavetable || wavetable_length < 2)) {
        err = EARS_ERR_GENERIC;
        object_error(e_ob, "No wavetable provided, or wavetable is too short.");
    } else if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error(e_ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    framecount   = buffer_getframecount(*dest);            // number of floats long the buffer is for a single channel
        
        // building envelope iterators
        t_llll *pitchenv = NULL;
        t_llll *velocityenv = NULL;
        
        if (breakpoints) {
            pitchenv = llll_clone(breakpoints);
            velocityenv = llll_clone(breakpoints);
            if (breakpoints->l_head && hatom_gettype(&breakpoints->l_head->l_hatom) == H_SYM) {
                // removing "breakpoints" symbol
                llll_behead(pitchenv);
                llll_behead(velocityenv);
            }
            for (t_llllelem *el = pitchenv->l_head; el; el = el->l_next) {
                if (hatom_gettype(&el->l_hatom) == H_LLLL) {
                    t_llll *ll = hatom_getllll(&el->l_hatom);
                    if (ll->l_size == 4)
                        llll_destroyelem(ll->l_tail);
                }
            }
            
            ears_llll_to_env_samples(pitchenv, duration_samps, sr_os, EARS_TIMEUNIT_DURATION_RATIO);
            
            bool has_no_velocity = false;
            for (t_llllelem *el = velocityenv->l_head; el; el = el->l_next) {
                if (hatom_gettype(&el->l_hatom) == H_LLLL) {
                    t_llll *ll = hatom_getllll(&el->l_hatom);
                    if (ll->l_size < 4) {
                        has_no_velocity = true;
                        break;
                    } else if (ll->l_size == 4) {
                        llll_swapelems(ll->l_head->l_next, ll->l_tail);
                        llll_destroyelem(ll->l_tail);
                    }
                }
            }
            if (has_no_velocity) {
                llll_clear(velocityenv);
                llll_appenddouble(velocityenv, velocity);
            } else {
                ears_llll_to_env_samples(velocityenv, duration_samps, sr_os, EARS_TIMEUNIT_DURATION_RATIO);
            }
        }

        // building envelope iterators
        t_ears_envelope_iterator eei_deltapitch = ears_envelope_iterator_create(pitchenv, 0, false, slopemapping);
        t_ears_envelope_iterator eei_vel = ears_envelope_iterator_create(velocityenv, velocity, false, slopemapping);

        // synthesizing
        double running_phase = 0;
        double t_step = (1./sr_os);
        for (long i = 0; i < framecount; i++) {
            double cents = ears_envelope_iterator_walk_interp(&eei_deltapitch, i, framecount) + midicents;
            double vel = ears_envelope_iterator_walk_interp(&eei_vel, i, framecount);
            double freq = ears_cents_to_hz(cents, middleAtuning);
            double amp = 1;
            
            switch (veltoamp_mode) {
                case EARS_VELOCITY_TO_AMPLITUDE:
                    amp = rescale(vel, 0., 127., amp_vel_min, amp_vel_max);
                    break;
                case EARS_VELOCITY_TO_DECIBEL:
                    amp = ears_db_to_linear(rescale(vel, 0., 127., amp_vel_min, amp_vel_max));
                    break;
                default:
                    break;
            }
            
//            sample[i] = amp * sin(running_phase);

            // TO DO: this resamplingfiltersize may be different (smaller?) than the one used below for reducing the sample rate
            sample[i] = amp * ears_synth_calc(running_phase, mode, wavetable, wavetable_length, resamplingfiltersize);

            running_phase += TWOPI * freq * t_step;
            while (running_phase > TWOPI)
                running_phase -= TWOPI;
            
        }
        
        buffer_setdirty(*dest);
        ears_buffer_unlocksamples(*dest);
        
        
        
        switch (mode) {
            case EARS_SYNTHMODE_SAWTOOTH:
            case EARS_SYNTHMODE_RECTANGULAR:
            case EARS_SYNTHMODE_TRIANGULAR:
            case EARS_SYNTHMODE_WAVETABLE:
                // a fourth order lowpass for antialiasing
                ears_buffer_onepole(e_ob, *dest, *dest, sr * 0.5, false);
                ears_buffer_onepole(e_ob, *dest, *dest, sr * 0.5, false);
                ears_buffer_onepole(e_ob, *dest, *dest, sr * 0.5, false);
                ears_buffer_onepole(e_ob, *dest, *dest, sr * 0.5, false);
                break;
                
            default:
                break;
        }
        
        if (oversampling > 1) {
            ears_buffer_resample(e_ob, *dest, 1./oversampling, resamplingfiltersize);
            ears_buffer_set_sr(e_ob, *dest, sr);
            
            // This would be faster but of course less precise:
            //            ears_buffer_decimate(e_ob, *dest, *dest, oversampling);
        }

        llll_free(pitchenv);
        llll_free(velocityenv);
    }
    return err;
}




t_ears_err ears_buffer_repeat(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long new_numsamples)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num frames/channel count
        }

        ears_buffer_set_size_and_numchannels(ob, dest, new_numsamples, channelcount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
//            t_atom_long	dest_channelcount = buffer_getchannelcount(dest);
//            t_atom_long	dest_framecount   = buffer_getframecount(dest);

            
            for (long f = 0; f < new_numsamples; f += framecount)
                sysmem_copyptr(orig_sample_wk, dest_sample + f * channelcount, channelcount * MIN(framecount, new_numsamples - f) * sizeof(float));
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}

t_ears_err ears_buffer_repeat_times(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double num_times)
{
    return ears_buffer_repeat(ob, source, dest, (long)ceil(num_times * ears_buffer_get_size_samps(ob, source)));
}


t_ears_err ears_buffer_offset(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long shift_samps)
{
    if (shift_samps < 0)
        return ears_buffer_crop(ob, source,dest, -shift_samps, -1);
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num frames and num channels
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, framecount + shift_samps, channelcount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            //            t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
            //            t_atom_long    dest_framecount   = buffer_getframecount(dest);
            
            for (long i = 0; i < shift_samps * channelcount; i++)
                dest_sample[i] = 0;
            sysmem_copyptr(orig_sample_wk, dest_sample + shift_samps * channelcount, channelcount * framecount * sizeof(float));
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_offset_subsampleprec(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double shift_samps, double resamplingfiltersize)
{
    if (floor(shift_samps) == shift_samps) // simple integer case
        return ears_buffer_offset(ob, source, dest, shift_samps);
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        t_atom_long    out_framecount = MAX(0, framecount + shift_samps);
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num frames and num channels
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, out_framecount, channelcount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            //            t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
            //            t_atom_long    dest_framecount   = buffer_getframecount(dest);
            
            for (long f = 0; f < out_framecount; f++) {
                for (long c = 0; c < channelcount; c++) {
                    double s = ears_interp_sinc(&(orig_sample_wk[c]), framecount, f - shift_samps, resamplingfiltersize, channelcount);
                    dest_sample[f * channelcount + c] = s;
                }
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_trim(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double amp_thresh_linear, char trim_start, char trim_end)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    if (amp_thresh_linear < 0) { // nothing to trim
        if (source != dest)
            return ears_buffer_clone(ob, source, dest);
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        // finding
        long start_samp = 0;
        long end_samp_included = framecount-1;
        
        if (trim_start) {
            while (start_samp < framecount) {
                double max_amp = 0;
                for (long c = 0; c < channelcount; c++)
                    max_amp = MAX(max_amp, orig_sample[start_samp*channelcount + c]);
                if (max_amp > amp_thresh_linear)
                    break;
                start_samp ++;
            }
        }
        if (trim_end) {
            while (end_samp_included >= 0) {
                double max_amp = 0;
                for (long c = 0; c < channelcount; c++)
                    max_amp = MAX(max_amp, orig_sample[end_samp_included*channelcount + c]);
                if (max_amp > amp_thresh_linear)
                    break;
                end_samp_included --;
            }
        }

        ears_buffer_unlocksamples(source);
        
        if (start_samp > 0 || end_samp_included < framecount - 1)
            ears_buffer_crop(ob, source, dest, start_samp, end_samp_included + 1); // crop wants as end sample the FIRST sample not to be taken
    }
    

    return err;
}



t_ears_err ears_buffer_decimate(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long factor)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        double sr = ears_buffer_get_sr(ob, source);
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num samples and num channels
        }

        ears_buffer_set_size_and_numchannels(ob, dest, framecount/factor, channelcount);
        ears_buffer_set_sr(ob, dest, sr/factor);

        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            long g = 0;
            for (long f = 0; f < framecount; f += factor, g++) {
                for (long c = 0; c < channelcount; c++) {
                    dest_sample[g * channelcount + c] = orig_sample_wk[f * channelcount + c];
                }
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}

t_ears_err ears_buffer_onepole(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double cutoff_freq, char highpass)
{
    double a0 = 1.;
    double b1 = 0.;
    
    double sr = ears_buffer_get_sr(ob, source);
   
    b1 = exp(-2.0 * PI * (cutoff_freq/sr));
    a0 = 1.0 - b1;
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long	channelcount = buffer_getchannelcount(source);		// number of floats in a frame
        t_atom_long	framecount   = buffer_getframecount(source);			// number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            long idx;
            float *prev = (float *)bach_newptr(channelcount * sizeof(float));
            for (long c = 0; c < channelcount; c++)
                prev[c] = 0.;
            
            for (long f = 0; f < framecount; f++) {
                for (long c = 0; c < channelcount; c++) {
                    idx = f * channelcount + c;
                    dest_sample[idx] = orig_sample_wk[idx] * a0 + prev[c] * b1;
                    prev[c] = dest_sample[idx];
                }
            }
            
            if (highpass) {
                for (long f = 0; f < framecount; f++) {
                    for (long c = 0; c < channelcount; c++) {
                        idx = f * channelcount + c;
                        dest_sample[idx] = orig_sample_wk[idx] - dest_sample[idx];
                    }
                }
            }

            bach_freeptr(prev);
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_biquad(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, double a0, double a1, double a2, double b1, double b2)
{
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, framecount);
        }
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            long idx;
            float *prev_fb_1 = (float *)bach_newptr(channelcount * sizeof(float));
            float *prev_fb_2 = (float *)bach_newptr(channelcount * sizeof(float));
            for (long c = 0; c < channelcount; c++)
                prev_fb_1[c] = prev_fb_2[c] = 0.;
            
            for (long f = 0; f < framecount; f++) {
                for (long c = 0; c < channelcount; c++) {
                    idx = f * channelcount + c;
                    dest_sample[idx] = orig_sample_wk[idx] * a0 + (f >= 1 ? orig_sample_wk[idx - channelcount] * a1 : 0) + (f >= 2 ? orig_sample_wk[idx - 2 * channelcount] * a2 : 0) - prev_fb_1[c] * b1 - prev_fb_2[c] * b2;
                    prev_fb_2[c] = prev_fb_1[c];
                    prev_fb_1[c] = dest_sample[idx];
                }
            }
            
            bach_freeptr(prev_fb_1);
            bach_freeptr(prev_fb_2);
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}

t_ears_err ears_buffer_dcfilter(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;

    if (dest != source)
        ears_buffer_clone(ob, source, dest);
    
    float *dest_sample = ears_buffer_locksamples(dest);
    
    if (!dest_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        for (long c = 0; c < channelcount; c++) {
            // computing dc offset iteratively (avoids numeric issues!)
            double dcoffset = 0;
            long t = 1;
            for (long f = 0; f < framecount; f++) {
                dcoffset += (dest_sample[f * channelcount + c] - dcoffset) / t;
                t++;
            }

            // removing it
            for (long f = 0; f < framecount; f++) {
                dest_sample[f * channelcount + c] -= dcoffset;
            }
        }
        
        ears_buffer_unlocksamples(dest);
    }
    return err;
}


// that is channels/samples transposition; NOT musical transposition
t_ears_err ears_buffer_transpose(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest)
{
    
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num frames/num channels
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, channelcount, framecount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            for (long f = 0; f < framecount; f++)
                for (long c = 0; c < channelcount; c++)
                    dest_sample[c * framecount + f] = orig_sample_wk[f * channelcount + c];
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}



t_ears_err ears_buffer_expr(t_object *ob, void *expr, /* this can be either a t_expr* or a t_lexpr* depending on EARS_EXPR_USE_LEXPR */
                            t_hatom *arguments, long num_arguments,
                            t_buffer_obj *dest, e_ears_normalization_modes normalization_mode, char envtimeunit, e_slope_mapping slopemapping,
                            e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (num_arguments == 0) {
        ears_buffer_set_size_samps(ob, dest, 0);
        return EARS_ERR_NONE;
    }
    
    // find reference buffer index (first introduced buffer)
    long ref_i = -1;
    for (long i = 0; i < num_arguments; i++)
        if (hatom_gettype(arguments+i) == H_OBJ) {
            ref_i = i;
            break;
        }
    
    if (ref_i < 0) {
        object_error(ob, "At least one buffer must be introduced as variable");
        ears_buffer_set_size_samps(ob, dest, 0);
        return EARS_ERR_GENERIC;
    }

    bool resampled = false;
    long i = 0;
    t_buffer_obj **source = (t_buffer_obj **)bach_newptrclear(num_arguments * sizeof(t_buffer_obj *));
    float **samples = (float **)bach_newptr(num_arguments * sizeof(float *));
    long *num_samples = (long *)bach_newptr(num_arguments * sizeof(long));
    bool *must_free_samples = (bool *)bach_newptrclear(num_arguments * sizeof(bool));
    long *num_channels = (long *)bach_newptr(num_arguments * sizeof(long));
    long *locked = (long *)bach_newptrclear(num_arguments * sizeof(long));
    long *argtype = (long *)bach_newptrclear(num_arguments * sizeof(long));
    double *numericargs = (double *)bach_newptrclear(num_arguments * sizeof(double));
    t_ears_envelope_iterator *eei = (t_ears_envelope_iterator *)bach_newptrclear(num_arguments * sizeof(t_ears_envelope_iterator));
    t_llll **eei_envs = (t_llll **)bach_newptrclear(num_arguments * sizeof(t_llll*));
    long *source_first_unique_idx = (long *)bach_newptrclear(num_arguments * sizeof(long));

    for (long i = 0; i < num_arguments; i++)
        source_first_unique_idx[i] = i;
    
    for (long i = 0; i < num_arguments; i++) {
        if (hatom_gettype(arguments+i) == H_OBJ) {
            argtype[i] = 0; // buffer
        } else if (is_hatom_number(arguments+i)) {
            argtype[i] = 1; // number
            numericargs[i] = hatom_getdouble(arguments + i);
        } else if (hatom_gettype(arguments + i) == H_LLLL){
            argtype[i] = 2; // breakpoint function
        } else {
            object_warn(ob, "Unknown argument type!");
            argtype[i] = -1;
        }
    }

    t_atom_long    channelcount = 0;
    long total_length_samps = 0;
    float *dest_sample = NULL;
    double sr = 0;
    
    channelcount = ears_buffer_get_numchannels(ob, (t_buffer_obj *)hatom_getobj(arguments+ref_i));
    sr = ears_buffer_get_sr(ob, (t_buffer_obj *)hatom_getobj(arguments+ref_i));
    
    for (i = 0; i < num_arguments; i++) {
        if (argtype[i] == 0) {
            source[i] = (t_buffer_obj *)hatom_getobj(arguments+i);
        }
    }

    for (long i = 0; i < num_arguments; i++) {
        if (!source[i] || source_first_unique_idx[i] != i)
            continue;
        for (long j = i+1; j < num_arguments; j++)
            if (source[j] && source[j] == source[i])
                source_first_unique_idx[j] = i;
    }
    
    for (i = 0; i < num_arguments; i++) {
        if (source[i] && (source_first_unique_idx[i] == i)) {
            samples[i] = ears_buffer_locksamples((t_buffer_obj *)hatom_getobj(arguments+i));
            locked[i] = true;
            if (!samples[i]) {
                err = EARS_ERR_CANT_WRITE;
                object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
                goto end;
            }
        } else if (source[i]) {
            samples[i] = samples[source_first_unique_idx[i]];
        }
    }


    
    ears_buffer_copy_format(ob, source[ref_i], dest, true); // we consider the first as "master", but will copy num frames and num channels later on
    
    // All buffers have been locked. Now we need to harmonize numchannels and sampsize.
    // As a rule: we take the property of the first one.
    for (i = 0; i < num_arguments; i++) {
        if (argtype[i] == 0) {
            num_channels[i] = ears_buffer_get_numchannels(ob, (t_buffer_obj *)hatom_getobj(arguments+i)); // it happens that copy_format doesn't work in changing the number of channels
            num_samples[i] = ears_buffer_get_size_samps(ob, (t_buffer_obj *)hatom_getobj(arguments+i));
        } else {
            // not a buffer
            num_channels[i] = 0;
            num_samples[i] = -1;
        }
    }
    
    ears_buffer_preprocess_sr_policies(ob, source, num_arguments, resamplingpolicy, resamplingfiltersize, resamplingmode, &sr, &resampled, samples, num_samples, must_free_samples, source_first_unique_idx);
    
    ears_buffer_set_sr(ob, dest, sr);
    
    // Getting max num samples and max num channels
    total_length_samps = 0;
    channelcount = 0;
    for (i = 0; i < num_arguments; i++) {
        if (num_samples[i] > total_length_samps)
            total_length_samps = num_samples[i];
        if (num_channels[i] > channelcount)
            channelcount = num_channels[i];
    }
    
    ears_buffer_set_size_and_numchannels(ob, dest, total_length_samps, channelcount);
    
    // changing envelopes due to the fact tha
    for (long i = 0; i < num_arguments; i++) {
        if (argtype[i] == 2) {
            eei_envs[i] = llll_clone(hatom_getllll(arguments + i));
            ears_llll_to_env_samples(eei_envs[i], total_length_samps, sr, envtimeunit);
            eei[i] = ears_envelope_iterator_create(eei_envs[i], 0., false, slopemapping);
        }
    }
    
    dest_sample = ears_buffer_locksamples(dest);
    if (!dest_sample) {
        err = EARS_ERR_CANT_WRITE;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
    } else {
        // erasing samples
        memset(dest_sample, 0, total_length_samps * channelcount * sizeof(float));
        
#ifdef EARS_EXPR_USE_LEXPR
        t_hatom vars[LEXPR_MAX_VARS];
        t_hatom stack[L_MAX_TOKENS];
        hatom_setdouble(stack, 0);
#else
        t_atom vars[9];
        t_atom res;
        atom_setfloat(&res, 0);
#endif
/*        // clearing all variables
        for (long i = 0; i < LEXPR_MAX_VARS; i++)
            hatom_setdouble(vars + i, 0.);
  */
        
        // writing samples
        if (expr) {
            long j, c;
            // first: setting all numeric args which are going to be constant
#ifdef EARS_EXPR_USE_LEXPR
            for (long i = 0; i < num_arguments && i < LEXPR_MAX_VARS; i++) {
                if (argtype[i] == 1) // number
                    hatom_setdouble(vars+i, numericargs[i]);
            }
#else
            for (long i = 0; i < num_arguments && i < 9; i++) {
                if (argtype[i] == 1) // number
                    atom_setfloat(vars+i, numericargs[i]);
            }
#endif

            for (c = 0; c < channelcount; c++) {
                
//                hatom_setdouble(vars+251, c+1);
                
                for (long i = 0; i < num_arguments; i++)
                    if (argtype[i] == 2) // function
                        ears_envelope_iterator_reset(eei+i);
                
#ifdef EARS_EXPR_USE_LEXPR
                for (j = 0; j < total_length_samps; j++) {
                    // setting variables
                    for (long i = 0; i < num_arguments && i < LEXPR_MAX_VARS; i++) {
                        // could be optimized by stripping the numeric arguments from the cycle, this is not the bottleneck though
                        switch (argtype[i]) {
                            case 0: // buffer
                                hatom_setdouble(vars+i, (c < num_channels[i] && j < num_samples[i]) ?
                                                samples[i][j * num_channels[i] + c] : 0);
                                break;
                                
                            case 2: // envelope
                                hatom_setdouble(vars+i, ears_envelope_iterator_walk_interp(eei+i, j, total_length_samps));
                                break;
                                
                            default:
                                break;
                        }
                    }
                    
                    // used to be like this:
                    // TO DO: optimize this stuff, should not be like this
                    //                    t_hatom *res = lexpr_eval(expr, vars);
//                    bach_freeptr(res);

//                    hatom_setdouble(vars+254, ((double)j)/sr);
  //                  hatom_setdouble(vars+253, total_length_samps > 0 ? ((double)j)/(total_length_samps - 1) : 0);
    //                hatom_setdouble(vars+252, j + 1);

                    lexpr_eval_upon((t_lexpr *)expr, vars, stack); // optimized version of lexpr_eval for many evaluations
                    dest_sample[j * channelcount + c] = hatom_getdouble(stack);
                }
#else
                for (j = 0; j < total_length_samps; j++) {
                    // setting variables
                    for (long i = 0; i < num_arguments && i < 9; i++) {
                        // could be optimized by stripping the numeric arguments from the cycle, this is not the bottleneck though
                        switch (argtype[i]) {
                            case 0: // buffer
                                atom_setfloat(vars+i, (c < num_channels[i] && j < num_samples[i]) ?
                                                samples[i][j * num_channels[i] + c] : 0);
                                break;
                                
                            case 2: // envelope
                                atom_setfloat(vars+i, ears_envelope_iterator_walk_interp(eei+i, j, total_length_samps));
                                break;
                                
                            default:
                                break;
                        }
                    }
                    expr_eval((t_expr *)expr, MIN(num_arguments, 9), vars, &res);
                    dest_sample[j * channelcount + c] = atom_getfloat(&res);
                }
#endif
                
            }
        }
        
        buffer_setdirty(dest);
        ears_buffer_unlocksamples(dest);
    }
    
end:
    for (i = 0; i < num_arguments; i++) {
        if (locked[i]) {
            if (must_free_samples[i])
                bach_freeptr(samples[i]);
            else if (source_first_unique_idx[i] == i)
                ears_buffer_unlocksamples((t_buffer_obj *)hatom_getobj(arguments+i));
        }
    }
    
    for (long i = 0; i < num_arguments; i++) {
        if (argtype[i] == 2) {
            llll_free(eei_envs[i]);
        }
    }
    
    bach_freeptr(source);
    bach_freeptr(samples);
    bach_freeptr(must_free_samples);
    bach_freeptr(num_samples);
    bach_freeptr(num_channels);
    bach_freeptr(locked);
    bach_freeptr(argtype);
    bach_freeptr(numericargs);
    bach_freeptr(eei);
    bach_freeptr(eei_envs);
    
    // Finally, we normalize if needed
    switch (normalization_mode) {
        case EARS_NORMALIZE_DO:
            ears_buffer_normalize_inplace(ob, dest, 1.);
            break;
            
        case EARS_NORMALIZE_OVERLOAD_PROTECTION_ONLY:
        {
            double maxabs = 0.;
            t_ears_err err = ears_buffer_get_maxabs(ob, dest, &maxabs);
            if (err == EARS_ERR_EMPTY_BUFFER)
                object_warn(ob, EARS_ERROR_BUF_EMPTY_BUFFER);
            if (err == EARS_ERR_NONE && maxabs > 1.) {
                object_warn(ob, "Output peak is %.3f, output buffer will be normalized due to overload protection.", maxabs);
                ears_buffer_normalize_inplace(ob, dest, 1.);
            }
        }
            break;
            
        case EARS_NORMALIZE_DONT:
        default:
            break;
    }
    
    
    return err;
}





void ears_writeaiff(t_object *buf, t_symbol *filename)
{
    t_atom a;
    atom_setsym(&a, filename);
    typedmess(buf, gensym("writeaiff"), 1, &a);
}

void ears_writewave(t_object *buf, t_symbol *filename)
{
    t_atom a;
    atom_setsym(&a, filename);
    typedmess(buf, gensym("writewave"), 1, &a);
}

void ears_writeflac(t_object *buf, t_symbol *filename)
{
    t_atom a;
    atom_setsym(&a, filename);
    typedmess(buf, gensym("writeflac"), 1, &a);
}

void ears_writeraw(t_object *buf, t_symbol *filename)
{
    t_atom a;
    atom_setsym(&a, filename);
    typedmess(buf, gensym("writeraw"), 1, &a);
}



t_symbol *get_conformed_resolved_path(t_symbol *filename)
{
    t_symbol *resolved_path = filename;
    if (path_absolutepath(&resolved_path, filename, NULL, 0) != MAX_ERR_NONE) {
        resolved_path = filename; // let's start from the old filename, if there was an issue
    }

    char conformed_path[MAX_PATH_CHARS];
    path_nameconform(resolved_path->s_name, conformed_path, PATH_STYLE_MAX, PATH_TYPE_BOOT);
    
    return gensym(conformed_path);
}




const char *get_filename_ext(const char *filename)
{
    const char *dot = strrchr(filename, '.');
    if (!dot || dot == filename) return "";
    return dot + 1;
}

void ears_print_supported_extensions(t_object *culprit, const char *unsupported_ext, bool write)
{
    char error_msg1[2048];
    char error_msg2[2048];
#ifdef EARS_MP3_WRITE_SUPPORT
    bool supportsmp3write = true;
#else
    bool supportsmp3write = false;
#endif
#ifdef EARS_MP3_READ_SUPPORT
    bool supportsmp3read = true;
#else
    bool supportsmp3read = false;
#endif
#ifdef EARS_WAVPACK_SUPPORT
    bool supportswavpack = true;
#else
    bool supportswavpack = false;
#endif
    bool supportsmp3 = (write ? supportsmp3write : supportsmp3read);
    if (unsupported_ext) {
        snprintf_zero(error_msg1, 2048, "The extension '%s' is not supported for %s.", unsupported_ext, write ? "writing" : "reading");
        snprintf_zero(error_msg2, 2048, "       Please use one of the following extensions: aif(f), wav(e),%s flac,%s or data.", supportsmp3 ? " mp3," : "", supportswavpack ? " wv (wavpack)," : "");
    } else {
        snprintf_zero(error_msg2, 2048, "Supported extensions for %s are: aif(f), wav(e),%s flac,%s or data.", write ? "writing" : "reading", supportsmp3 ? " mp3," : "", supportswavpack ? " wv (wavpack)," : "");

    }
    object_error(culprit, error_msg1);
    object_error(culprit, error_msg2);
}

void ears_buffer_write(t_object *buf, t_symbol *filename, t_object *culprit, t_ears_encoding_settings *settings)
{
    const char *ext = get_filename_ext(filename->s_name);
    if (!strcmp(ext, "aif") || !strcmp(ext, "aiff"))
        ears_writeaiff(buf, filename);
    else if (!strcmp(ext, "wav") || !strcmp(ext, "wave"))
        ears_writewave(buf, filename);
    else if (!strcmp(ext, "flac"))
        ears_writeflac(buf, filename);
    else if (!strcmp(ext, "data"))
        ears_writeraw(buf, filename);
#ifdef EARS_MP3_WRITE_SUPPORT
    else if (!strcmp(ext, "mp3"))
        ears_writemp3(buf, filename, settings);
#endif
#ifdef EARS_WAVPACK_SUPPORT
    else if (!strcmp(ext, "wv") || !strcmp(ext, "wavpack"))
        ears_writewavpack(buf, filename, settings);
#endif
    else
        ears_print_supported_extensions(culprit, ext, true);
}


void ears_envelope_get_max_x(t_llllelem *el, t_atom *a_max)
{
    atom_setlong(a_max, 0);
    if (el && hatom_gettype(&el->l_hatom) == H_LLLL) {
        t_llll *ll = hatom_getllll(&el->l_hatom);
        if (ll->l_tail && hatom_gettype(&ll->l_tail->l_hatom) == H_LLLL) {
            t_llll *subll = hatom_getllll(&ll->l_tail->l_hatom);
            if (subll && subll->l_head) {
                if (hatom_gettype(&subll->l_head->l_hatom) == H_LONG)
                    atom_setlong(a_max, hatom_getlong(&subll->l_head->l_hatom));
                else
                    atom_setfloat(a_max, hatom_getdouble(&subll->l_head->l_hatom));
            }
        }
    }
}



t_ears_err ears_buffer_get_split_points_samps_silence(t_object *ob, t_buffer_obj *buf, double thresh_linear, double min_silence_samps, t_llll **samp_start, t_llll **samp_end, char keep_silence)
{
    if (!buf) {
        *samp_start = llll_get();
        *samp_end = llll_get();
        return EARS_ERR_NO_BUFFER;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        *samp_start = llll_get();
        *samp_end = llll_get();
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        char in_silence = true;
        long curr_num_silence_samps = 0;
        char reverse = (keep_silence == 2);
        *samp_start = llll_get();
        *samp_end = llll_get();
        
        t_atom_long    channelcount = buffer_getchannelcount(buf);
        t_atom_long    framecount   = buffer_getframecount(buf);
        
        if (reverse) {
            char testing_silence = false;
            in_silence = false;
            for (long f = 0; f < framecount; f++) {
                float max_amp = 0;
                for (long c = 0; c < channelcount; c++)
                    max_amp = MAX(max_amp, fabs(sample[f * channelcount + c]));
                
                if (!in_silence && max_amp < thresh_linear) {
                    curr_num_silence_samps++;
                    in_silence = true;
                    testing_silence = true;
                } else if (in_silence) {
                    if (max_amp >= thresh_linear) {
                        if (!testing_silence)
                            llll_appendlong(*samp_end, f);
                        in_silence = false;
                        curr_num_silence_samps = 0;
                    } else {
                        curr_num_silence_samps++;
                        if (testing_silence && curr_num_silence_samps >= min_silence_samps) {
                            testing_silence = false;
                            llll_appendlong(*samp_start, f - curr_num_silence_samps + 1);
                        }
                    }
                }
            }
            
            while ((*samp_end)->l_size < (*samp_start)->l_size)
                llll_appendlong(*samp_end, framecount);

        } else {
            char in_silence = true;
            for (long f = 0; f < framecount; f++) {
                float max_amp = 0;
                for (long c = 0; c < channelcount; c++)
                    max_amp = MAX(max_amp, fabs(sample[f * channelcount + c]));
                
                if (!in_silence && max_amp < thresh_linear) {
                    curr_num_silence_samps++;
                    if (curr_num_silence_samps >= min_silence_samps) {
                        llll_appendlong(*samp_end, f - curr_num_silence_samps + 1);
                        in_silence = true;
                    }
                } else if (in_silence) {
                    if (max_amp >= thresh_linear) {
                        llll_appendlong(*samp_start, f);
                        in_silence = false;
                        curr_num_silence_samps = 0;
                    } else {
                        curr_num_silence_samps++;
                    }
                }
            }
            
            while ((*samp_end)->l_size < (*samp_start)->l_size)
                llll_appendlong(*samp_end, framecount);
        }
        
        if (keep_silence == 1) {
            t_llllelem *s, *e;
            for (s = (*samp_start)->l_head->l_next, e = (*samp_end)->l_head; e; s = s ? s->l_next : NULL, e=e->l_next) {
                if (!s)
                    hatom_setlong(&e->l_hatom, framecount);
                else
                    hatom_setlong(&e->l_hatom, hatom_getlong(&s->l_hatom));
            }
        }

        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}


t_ears_err ears_buffer_get_split_points_samps_onset(t_object *ob, t_buffer_obj *buf, double attack_thresh_linear, double release_thresh_linear, double min_silence_samps, long lookahead_samps, long smoothingwin_samps, t_llll **samp_start, t_llll **samp_end, char keep_first)
{
    if (!buf) {
        *samp_start = llll_get();
        *samp_end = llll_get();
        return EARS_ERR_NO_BUFFER;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        *samp_start = llll_get();
        *samp_end = llll_get();
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        *samp_start = llll_get();
        *samp_end = llll_get();

        bool first_samp_is_attack = false;
        bool in_attack = 0;
        t_atom_long    channelcount = buffer_getchannelcount(buf);
        t_atom_long    framecount   = buffer_getframecount(buf);
        
        // build envelope with MAX window filtering
        float *ampenv = (float *)bach_newptr(framecount * sizeof(float));
        float *temp = (float *)bach_newptr(framecount * sizeof(float));

        for (long f = 0; f < framecount; f++) {
            float max_amp = 0;
            for (long c = 0; c < channelcount; c++)
                max_amp = MAX(max_amp, fabs(sample[f * channelcount + c]));
            temp[f] = max_amp;
        }

        // backwards MAX window: this is a slow implementation, there are niftier ways
        for (long f = 0; f < framecount; f++) {
            float max_amp = 0;
            for (int i = 0; i < smoothingwin_samps && f-i >= 0; i++) {
                max_amp = MAX(max_amp, temp[f-i]);
            }
            ampenv[f] = max_amp;
        }

        // finding split points
        llll_appendlong(*samp_start, 0);
        for (long f = 0; f < framecount; f++) {
            double amp = ampenv[f+lookahead_samps];
            if (f == 0) {
                for (long i = 0; i < lookahead_samps; i++)
                    amp = MAX(amp, ampenv[i]);
            }
            
            if (!in_attack) {
                if (amp > attack_thresh_linear) {
                    // start an attack here.
                    if (f > 0) {
                        llll_appendlong(*samp_end, f);
                        llll_appendlong(*samp_start, f);
                    } else {
                        first_samp_is_attack = true;
                    }
                    in_attack = true;
                } else {
                    // nothing happens, continue
                }
            } else {
                if (amp < release_thresh_linear) {
                    // attack ends
                    in_attack = false;
                }
            }
        }
        
        while ((*samp_end)->l_size < (*samp_start)->l_size)
            llll_appendlong(*samp_end, framecount);
        
        if (keep_first == 0 && !first_samp_is_attack && (*samp_start)->l_size > 0 && (*samp_end)->l_size > 0) {
            llll_destroyelem((*samp_start)->l_head);
            llll_destroyelem((*samp_end)->l_head);
        }
        
        bach_freeptr(ampenv);
        bach_freeptr(temp);
        ears_buffer_unlocksamples(buf);
    }
    
    return err;
}


std::vector<float> ears_buffer_get_sample_vector_channel(t_object *ob, t_buffer_obj *buf, long channelnum)
{
    std::vector<float> res;
    if (!buf) {
        return res;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return res;
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);
        t_atom_long    framecount   = buffer_getframecount(buf);
        
        for (long f = 0; f < framecount; f++) {
            res.push_back(sample[f * channelcount + channelnum]);
        }
        ears_buffer_unlocksamples(buf);
    }
    
    return res;
}

std::vector<std::vector<float>> ears_buffer_get_sample_vector(t_object *ob, t_buffer_obj *buf)
{
    std::vector<std::vector<float>> res;
    if (!buf) {
        return res;
    }
    
    long numchans = ears_buffer_get_numchannels(ob, buf);
    for (long i = 0; i < numchans; i++)
        res.push_back(ears_buffer_get_sample_vector_channel(ob, buf, i));
    return res;
}


std::vector<float> ears_buffer_get_sample_vector_mono(t_object *ob, t_buffer_obj *buf)
{
    std::vector<float> res;
    if (!buf) {
        return res;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *sample = ears_buffer_locksamples(buf);
    
    if (!sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return res;
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(buf);
        t_atom_long    framecount   = buffer_getframecount(buf);
        
        for (long f = 0; f < framecount; f++) {
            double sum = 0;
            for (long c = 0; c < channelcount; c++)
                sum += sample[f * channelcount + c];
            res.push_back(sum/channelcount);
        }
        ears_buffer_unlocksamples(buf);
    }
    
    return res;
}


t_ears_spectralbuf_metadata spectralbuf_metadata_get_empty(){
    t_ears_spectralbuf_metadata data;
    data.original_audio_signal_sr = 0;
    data.binsize = 0;
    data.binoffset = 0;
    data.bins = NULL;
    data.binunit = EARS_FREQUNIT_UNKNOWN;
    data.type = _llllobj_sym_none;
    return data;
}

bool spectralbuf_metadata_eq(t_ears_spectralbuf_metadata *data1, t_ears_spectralbuf_metadata *data2)
{
    if (!data1 && data2)
        return false;
    if (!data2 && data1)
        return false;
    if (!data1 && !data2)
        return true;
    if (data1->original_audio_signal_sr != data2->original_audio_signal_sr)
        return false;
    if (data1->binsize != data2->binsize)
        return false;
    if (data1->binoffset != data2->binoffset)
        return false;
    if (data1->binunit != data2->binunit)
        return false;
    if (data1->type != data2->type)
        return false;
    if (llll_eq_ignoretype(data1->bins, data2->bins) == 0)
        return false;
    return true;
}

void ears_spectralbuf_metadata_fill(t_ears_spectralbuf_metadata *data, double original_audio_signal_sr, double binsize, double binoffset, e_ears_frequnit binunit, t_symbol *type, t_llll *bins, bool also_free_bins)
{
    data->original_audio_signal_sr = original_audio_signal_sr;
    data->binsize = binsize;
    data->binoffset = binoffset;
    data->binunit = binunit;
    data->type = type;
    if (also_free_bins)
        llll_free(data->bins);
    data->bins = bins ? llll_clone(bins) : NULL;
}

t_llll *ears_ezarithmser(double from, double step, long numitems)
{
    t_llll *out = llll_get();
    double curr = from;
    for (long i = 0; i < numitems; i++) {
        llll_appenddouble(out, curr);
        curr += step;
    }
    return out;
}







t_ears_err ears_buffer_compress(t_object *ob, t_buffer_obj *source, t_buffer_obj *sidechain, t_buffer_obj *dest,
                                double threshold_dB, double ratio, double kneewidth_dB,
                                double attack_time_samps, double release_time_samps,
                                double makeup_dB)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    double half_kneewidth_dB = kneewidth_dB / 2.;
    float *source_sample = ears_buffer_locksamples(source);
    bool inplace = false, separate_sidechain = false;
    
    if (!source_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        
        t_atom_long    source_channelcount = buffer_getchannelcount(source);
        t_atom_long    source_framecount   = buffer_getframecount(source);
        t_atom_long    sidechain_channelcount, sidechain_framecount;

        float *dest_sample = NULL;
        if (source != dest) {
            inplace = false;
            ears_buffer_copy_format_and_set_size_samps(ob, source, dest, source_framecount);
            dest_sample = ears_buffer_locksamples(dest);
        } else {
            inplace = true;
            dest_sample = source_sample;
        }
        
        float *sidechain_sample;
        if (sidechain == source || !sidechain) {
            separate_sidechain = false;
            sidechain_sample = source_sample;
            sidechain_channelcount = source_channelcount;
            sidechain_framecount = source_framecount;
        } else {
            separate_sidechain = true;
            sidechain_channelcount = buffer_getchannelcount(sidechain);
            sidechain_framecount = buffer_getframecount(sidechain);
            sidechain_sample = ears_buffer_locksamples(sidechain);
        }
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        } else {
            t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
            t_atom_long    dest_framecount   = buffer_getframecount(dest);
            t_atom_long    max_framecount = MAX(dest_framecount, source_framecount);

            double yL = 0, yL_prev = 0;
            for (long i = 0; i < max_framecount; i++) {

                // we use the page https://github.com/p-hlp/CTAGDRC as a tutorial
                
                // 1) level detection: it's the maximum across the channel of the sidechain signal
                float input = 0;
                if (i < sidechain_framecount) {
                    for (long c = 0; c < sidechain_channelcount; c++)
                        input = MAX(input, std::abs(sidechain_sample[i * sidechain_channelcount + c]));
                }
                
                // 2) dB conversion
                float input_db = ears_linear_to_db(input);
                float output_gain_db;

                // 3) gain computation
                if (input_db - threshold_dB < -half_kneewidth_dB) {
                    // nothing to do: copy
                    output_gain_db = 0;
                } else if (input_db - threshold_dB <= half_kneewidth_dB) {
                    float temp = input_db - threshold_dB + half_kneewidth_dB;
                    output_gain_db = (1./ratio - 1) * temp * temp / (2 * kneewidth_dB);
                } else {
                    output_gain_db = threshold_dB + (input_db-threshold_dB)/ratio - input_db;
                }
                
                // 4) ballistics
                double alpha_attack = exp(-1./attack_time_samps);
                double alpha_release = exp(-1./release_time_samps);
                
                // smooth branching peek detector
                if (output_gain_db > yL_prev) {
                    yL = alpha_attack * yL_prev + (1 - alpha_attack) * output_gain_db;
                } else {
                    yL = alpha_release * yL_prev + (1 - alpha_release) * output_gain_db;
                }
                
                yL_prev = yL;
                
                // 5) linear conversion
                double gain_to_apply_linear = ears_db_to_linear(yL + makeup_dB);
                
                for (long c = 0; c < dest_channelcount; c++)
                    dest_sample[i * dest_channelcount + c] = source_sample[i * dest_channelcount + c] * gain_to_apply_linear;
            }
            if (!inplace)
                ears_buffer_unlocksamples(dest);
        }
        
        if (separate_sidechain)
            ears_buffer_unlocksamples(sidechain);
        
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_rms_envelope(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long winsize_samps)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);
        t_atom_long    framecount   = buffer_getframecount(source);
        
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change channels/framecount: that'll be done later on
        }
        
        ears_buffer_set_size_and_numchannels(ob, dest, framecount, channelcount);
        
        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            t_atom_long    dest_channelcount = buffer_getchannelcount(dest);
            t_atom_long    dest_framecount   = buffer_getframecount(dest);
            
            if (dest_channelcount != channelcount) { // should never happen
                channelcount = MIN(dest_channelcount, channelcount);
                dest_channelcount = channelcount;
            }

            if (dest_framecount != framecount) { // should never happen
                framecount = MIN(dest_framecount, framecount);
                dest_framecount = framecount;
            }

            // TODO: convolution that can be greatly optimized!!!!
            for (long c = 0; c < channelcount; c++) {
                for (long f = 0; f < framecount; f++) {
                    // computing RMS over the window
                    double tot = 0.;
                    long count = 0;
                    for (long w = f-winsize_samps/2; w < f-(winsize_samps/2)+winsize_samps; w++) {
                        if (w >= 0 && w < framecount) {
                            tot += orig_sample[w*channelcount + c] * orig_sample[w*channelcount + c];
                            count++;
                        }
                    }
                    dest_sample[f * channelcount + c] = sqrt(tot/count);
                }
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


long ears_buffer_get_mono_minindex_weighted(t_object *ob, t_buffer_obj *source, t_buffer_obj *mask)
{
    double min = 0;
    long minsample = -1;

    float *source_sample = ears_buffer_locksamples(source);
    float *mask_sample = ears_buffer_locksamples(mask);

    if (!source_sample || !mask_sample) {
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (framecount == 0) {
            object_error((t_object *)ob, EARS_ERROR_BUF_EMPTY_BUFFER);
        } else {
            min = DBL_MAX;
            minsample = -1;
            
            for (long i = 0; i < framecount; i++) {
                if (mask_sample[i] == 1 && source_sample[i] < min) {
                    min = source_sample[i];
                    minsample = i;
                }
            }
        }
    }
    
    ears_buffer_unlocksamples(source);
    ears_buffer_unlocksamples(mask);
    
    return minsample;
}




t_ears_err ears_buffer_squash_waveform(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, long delta_num_samps, long framesize_samps, long rms_calc_framesize_samps, long xfade_samples, e_ears_fade_types fade_type, double fade_curve, e_slope_mapping slopemapping)
{
    long numchannels = ears_buffer_get_numchannels(ob, source);
    t_ears_err err = EARS_ERR_NONE;
    
    if (numchannels <= 0) {
        ears_buffer_clone(ob, source, dest);
        return EARS_ERR_EMPTY_BUFFER;
    }
    
    t_buffer_obj *source_mono = ears_buffer_make(NULL);
    t_buffer_obj *envelope = ears_buffer_make(NULL);
    t_buffer_obj *mask = ears_buffer_make(NULL);
    
    ears_buffer_clone(ob, source, source_mono);
    ears_buffer_convert_numchannels(ob, source_mono, 1, EARS_CHANNELCONVERTMODE_CYCLE, EARS_CHANNELCONVERTMODE_CYCLE);
    ears_buffer_clone(ob, source, dest);

    ears_buffer_rms_envelope(ob, source_mono, envelope, rms_calc_framesize_samps);
    ears_buffer_clone(ob, envelope, mask);
    ears_buffer_fill_inplace(ob, mask, 1.);

    t_buffer_obj *TESTenv = ears_buffer_get_object(gensym("env"));
    ears_buffer_clone(ob, envelope, TESTenv);

    long orig_num_samps = ears_buffer_get_size_samps(ob, envelope);
    
    if (delta_num_samps == 0) {
        ears_buffer_clone(ob, source, dest);
    } else if (delta_num_samps < 0 && -delta_num_samps >= orig_num_samps) {
        ears_buffer_clone(ob, source, dest);
        ears_buffer_clear(ob, dest);
    } else if (delta_num_samps < 0) { // squash
        float *dest_sample = ears_buffer_locksamples(dest);
        float *mask_sample = ears_buffer_locksamples(mask);
        if (!dest_sample) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
            ears_buffer_unlocksamples(dest);
        } else {
            
            long dest_numsamples = ears_buffer_get_size_samps(ob, mask);
            while (true) {
                long minsample = ears_buffer_get_mono_minindex_weighted(ob, envelope, mask);
                if (minsample == -1)
                    break;
                
                long start_f = MIN(MAX(0, minsample - framesize_samps / 2), orig_num_samps);
                long end_f = MIN(MAX(0, minsample - framesize_samps / 2 + framesize_samps), orig_num_samps);
                
                if (start_f > end_f) { // should never happen
                    object_error(ob, "Internal error!");
                    break;
                }
                
                for (long f = start_f; f < end_f; f++) {
                    if (mask_sample[f] == 1)
                        dest_numsamples--;
                    mask_sample[f] = 0;
                }
                
                // TODO: in reality we should also account for cross fades between regions.

                if (dest_numsamples < orig_num_samps + delta_num_samps)
                    break;
            }
            
            // creating regions
            std::vector<long> regionstartsamp;
            std::vector<long> regionendsamp;
            std::vector<long> xfade_samples_reg;

            double curr_mask = 0;
            for (long f = 0; f < orig_num_samps; f++) {
                if (curr_mask == 0 && mask_sample[f] == 1) {
                    // beginning of a region
                    regionstartsamp.push_back(f);
                    curr_mask = 1.;
                } else if (curr_mask == 1 && mask_sample[f] == 0) {
                    // end of a region
                    regionendsamp.push_back(f);
                    curr_mask = 0.;
                }
            }
            if (curr_mask == 1)
                regionendsamp.push_back(orig_num_samps);
            
            if (regionendsamp.size() != regionstartsamp.size()) {
                object_error(ob, "Internal error!");
            }
            
            long num_regions = MIN(regionstartsamp.size(), regionendsamp.size());
            t_buffer_obj **chunks = (t_buffer_obj **)bach_newptr(num_regions * sizeof(t_buffer_obj *));
            for (long r = 0; r < num_regions; r++) {
                chunks[r] = ears_buffer_make(NULL);
                xfade_samples_reg.push_back(xfade_samples);
            }
            
            ears_buffer_split(ob, source, chunks, &regionstartsamp[0], &regionendsamp[0], num_regions);

            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);

            ears_buffer_join(ob, chunks, num_regions, dest, &xfade_samples_reg[0], false, fade_type, fade_curve, slopemapping, EARS_RESAMPLINGPOLICY_DONT, 11, EARS_RESAMPLINGMODE_SINC);
            
            for (long r = 0; r < num_regions; r++)
                ears_buffer_free(chunks[r]);
            bach_freeptr(chunks);
        }
        
        ears_buffer_unlocksamples(mask);

    } else if (delta_num_samps > 0){
        object_error(ob, "Time-domain timesquash does not support adding time.");
        ears_buffer_clone(ob, source, dest);
        return EARS_ERR_GENERIC;
    }
    
    ears_buffer_free(source_mono);
    ears_buffer_free(envelope);
    ears_buffer_free(mask);
    
    return err;
}



t_ears_err ears_buffer_interp(t_object *ob, t_buffer_obj *from, t_buffer_obj *to, long numinterp, t_buffer_obj **dest, long resamplingfiltersize, e_ears_resamplingmode resamplingmode, bool equalpowerinterp)
{
    t_ears_err err = EARS_ERR_NONE, this_err = EARS_ERR_NONE;
    long from_framecount = ears_buffer_get_size_samps(ob, from);
    long to_framecount = ears_buffer_get_size_samps(ob, to);
    t_buffer_obj *temp1 = ears_buffer_make(NULL);
    t_buffer_obj *temp2 = ears_buffer_make(NULL);
    t_buffer_obj *temps[2];
    temps[0] = temp1;
    temps[1] = temp2;
    long offsets[2];
    offsets[0] = 0;
    offsets[1] = 0;
    for (long i = 0; i < numinterp; i++) {
        double factor = rescale(i, -1, numinterp, 0, 1);
        t_buffer_obj *thisdest = dest[i];
        long this_size = (long)round(rescale(factor, 0, 1, from_framecount, to_framecount));
        ears_buffer_copy_format_and_set_size_samps(ob, from, thisdest, this_size);
        
        ears_buffer_clone(ob, from, temp1);
        ears_buffer_clone(ob, to, temp2);

        if (this_size != from_framecount && (this_err = ears_buffer_resample(ob, temp1, ((double)this_size)/from_framecount, resamplingfiltersize)))
            err = EARS_ERR_GENERIC;

        if (this_size != to_framecount && (this_err = ears_buffer_resample(ob, temp2, ((double)this_size)/to_framecount, resamplingfiltersize)))
            err = EARS_ERR_GENERIC;

        t_llll *gains = llll_get();
        if (equalpowerinterp) {
            llll_appenddouble(gains, sqrt(1.-factor));
            llll_appenddouble(gains, sqrt(factor));
        } else {
            llll_appenddouble(gains, 1.-factor);
            llll_appenddouble(gains, factor);
        }
        
        if ((this_err = ears_buffer_mix(ob, temps, 2, thisdest, gains, offsets, EARS_NORMALIZE_DONT, k_SLOPE_MAPPING_BACH, EARS_RESAMPLINGPOLICY_DONT, resamplingfiltersize, resamplingmode)))
            err = this_err;

        llll_free(gains);
    }
    ears_buffer_free(temp1);
    ears_buffer_free(temp2);
    
    return err;
}



t_ears_err ears_buffer_average(t_object *ob, long num_sources, t_buffer_obj **sources, t_buffer_obj *dest, double *weights, long resamplingfiltersize, e_ears_resamplingmode resamplingmode, bool keep_length, long reference_buffer_for_length)
{
    t_ears_err err = EARS_ERR_NONE, this_err = EARS_ERR_NONE;
    
    if (num_sources <= 0) {
        object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }

    ears_buffer_copy_format(ob, sources[num_sources/2], dest);
    
    double outframecount_float = 0;
    double totweight = 0;
    for (long i = 0; i < num_sources; i++) {
        outframecount_float += ears_buffer_get_size_samps(ob, sources[i]) * (weights ? weights[i] : 1);
        totweight += (weights ? weights[i] : 1);
    }
    
    if (totweight == 0) {
        ears_buffer_clear(ob, dest);
        object_error(ob, "Total weight is zero!");
        return EARS_ERR_GENERIC;
    }
    
    outframecount_float /= totweight;
    long outframecount = (long)round(outframecount_float);
    if (keep_length)
        outframecount = ears_buffer_get_size_samps(ob, sources[reference_buffer_for_length]);
    
    if (outframecount <= 0) {
        ears_buffer_clear(ob, dest);
        return EARS_ERR_EMPTY_BUFFER;
    }
    
    
    t_buffer_obj **temps = (t_buffer_obj **)bach_newptr(num_sources * sizeof(t_buffer_obj *));
    long *offsets = (long *)bach_newptr(num_sources * sizeof(long));
    t_llll *gains_ll = llll_get();
    for (long i = 0; i < num_sources; i++) {
        temps[i] = ears_buffer_make(NULL);
        ears_buffer_clone(ob, sources[i], temps[i]);
        long this_size = ears_buffer_get_size_samps(ob, sources[i]);
        if (this_size == 0) {
            ears_buffer_set_size_samps(ob, temps[i], outframecount);
            ears_buffer_fill_inplace(ob, temps[i], 0);
        } else {
            if ((this_err = ears_buffer_resample(ob, temps[i], ((double)outframecount)/ears_buffer_get_size_samps(ob, sources[i]), resamplingfiltersize)))
                err = this_err;
        }
        llll_appenddouble(gains_ll, weights ? weights[i] : 1);
        offsets[i] = 0;
    }
    
    if ((this_err = ears_buffer_mix(ob, temps, num_sources, dest, gains_ll, offsets, EARS_NORMALIZE_DONT, k_SLOPE_MAPPING_BACH, EARS_RESAMPLINGPOLICY_DONT, resamplingfiltersize, resamplingmode)))
        err = this_err;
        
    for (long i = 0; i < num_sources; i++) {
        ears_buffer_free(temps[i]);
    }

    bach_freeptr(temps);
    bach_freeptr(offsets);
    
    return err;
}


e_ears_resamplingmode ears_symbol_to_resamplingmode(t_object *ob, t_symbol *s)
{
    if (!s || !s->s_name) {
        object_warn(ob, "Invalid resampling mode! Defaulting to sinc.");
        return EARS_RESAMPLINGMODE_SINC;
    }
    if (strcmp_case_insensitive(s->s_name, "linear") == 0)
        return EARS_RESAMPLINGMODE_LINEAR;
    if (strcmp_case_insensitive(s->s_name, "quadratic") == 0)
        return EARS_RESAMPLINGMODE_QUADRATIC;
    if (strcmp_case_insensitive(s->s_name, "cubic") == 0)
        return EARS_RESAMPLINGMODE_CUBIC;
    if (strcmp_case_insensitive(s->s_name, "sah") == 0 || strcmp_case_insensitive(s->s_name, "sampleandhold") == 0 || strcmp_case_insensitive(s->s_name, "sample and hold") == 0 || strcmp_case_insensitive(s->s_name, "sampleandhold") == 0)
        return EARS_RESAMPLINGMODE_SAMPLEANDHOLD;
    if (strcmp_case_insensitive(s->s_name, "nn") == 0 || strcmp_case_insensitive(s->s_name, "nearestneighbor") == 0 || strcmp_case_insensitive(s->s_name, "nearestneighbour") == 0 ||  strcmp_case_insensitive(s->s_name, "nearest neighbor") == 0 || strcmp_case_insensitive(s->s_name, "nearest neighbour") == 0 || strcmp_case_insensitive(s->s_name, "nearestneighbor") == 0 || strcmp_case_insensitive(s->s_name, "nearestneighbour") == 0)
        return EARS_RESAMPLINGMODE_NEARESTNEIGHBOR;
    if (strcmp_case_insensitive(s->s_name, "sinc") == 0)
        return EARS_RESAMPLINGMODE_SINC;

    object_warn(ob, "Invalid resampling mode! Defaulting to sinc.");
    return EARS_RESAMPLINGMODE_SINC;
}


t_ears_err ears_buffer_eq(t_object *ob, t_buffer_obj *buf1, t_buffer_obj *buf2, long *ans)
{
    t_ears_err err = EARS_ERR_NONE;
    float *sample1 = ears_buffer_locksamples(buf1);
    *ans = 1;
    
    if (!sample1) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        double sr1 = ears_buffer_get_sr(ob, buf1);
        long channelcount1 = ears_buffer_get_numchannels(ob, buf1);
        long framecount1 = ears_buffer_get_size_samps(ob, buf1);
        bool spectral1 = ears_buffer_is_spectral(ob, buf1);
        t_ears_spectralbuf_metadata *data1 = spectral1 ? ears_spectralbuf_metadata_get(ob, buf1) : NULL;
        
        float *sample2 = ears_buffer_locksamples(buf2);
        if (!sample2) {
            err = EARS_ERR_CANT_READ;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        } else {
            double sr2 = ears_buffer_get_sr(ob, buf2);
            long channelcount2 = ears_buffer_get_numchannels(ob, buf2);
            long framecount2 = ears_buffer_get_size_samps(ob, buf2);
            bool spectral2 = ears_buffer_is_spectral(ob, buf1);
            t_ears_spectralbuf_metadata *data2 = spectral2 ? ears_spectralbuf_metadata_get(ob, buf2) : NULL;

            if (sr2 != sr1 || channelcount2 != channelcount1 || framecount2 != framecount1 || spectral1 != spectral2 || spectralbuf_metadata_eq(data1, data2) == false) {
                *ans = 0;
            } else {
                *ans = 1;
                for (long i = 0; i < framecount1 * channelcount1; i++) {
                    if (sample1[i] != sample2[i]) {
                        *ans = 0;
                        break;
                    }
                }
            }
            ears_buffer_unlocksamples(buf2);
        }
        
        ears_buffer_unlocksamples(buf1);
    }
    return err;
}


t_ears_err ears_buffer_neq(t_object *ob, t_buffer_obj *buf1, t_buffer_obj *buf2, long *ans)
{
    t_ears_err err = ears_buffer_eq(ob, buf1, buf2, ans);
    *ans = 1 - (*ans);
    return err;
}



t_ears_err ears_buffer_todiffs(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;
    
    long size = ears_buffer_get_size_samps(ob, source);
    if (size <= 1) {
        ears_buffer_clone(ob, source, dest);
        ears_buffer_clear(ob, dest);
        return size <= 0 ? EARS_ERR_EMPTY_BUFFER : EARS_ERR_NONE;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
            sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num samples and num channels
        }

        ears_buffer_set_size_and_numchannels(ob, dest, framecount-1, channelcount);

        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            if (buffer_getchannelcount(dest) != channelcount ||
                buffer_getframecount(dest) != framecount - 1) {
                object_error(ob, "Internal error.");
            } else {
                
                for (long c = 0; c < channelcount; c++) {
                    for (long f = 0; f < framecount - 1; f ++) {
                        dest_sample[f * channelcount + c] = orig_sample_wk[(f+1) * channelcount + c] - orig_sample_wk[f * channelcount + c];
                    }
                }
                
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) // inplace operation!
            bach_freeptr(orig_sample_wk);
        else
            ears_buffer_unlocksamples(source);
    }
    
    return err;
}


t_ears_err ears_buffer_fromdiffs(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, float *startvalues, long numstartvalues)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;

    
    if (numstartvalues <= 0) {
        object_error(ob, "No start sample defined.");
        return EARS_ERR_GENERIC;
    }
    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    float *orig_sample_wk = NULL;
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source == dest) { // inplace operation!
            if (framecount > 0) {
                orig_sample_wk = (float *)bach_newptr(channelcount * framecount * sizeof(float));
                sysmem_copyptr(orig_sample, orig_sample_wk, channelcount * framecount * sizeof(float));
            } else {
                orig_sample_wk = NULL;
            }
            ears_buffer_unlocksamples(source);
        } else {
            orig_sample_wk = orig_sample;
            ears_buffer_copy_format(ob, source, dest, true); // won't change num samples and num channels
        }

        ears_buffer_set_size_and_numchannels(ob, dest, framecount+1, channelcount);

        float *dest_sample = ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            if (buffer_getchannelcount(dest) != channelcount ||
                buffer_getframecount(dest) != framecount + 1) {
                object_error(ob, "Internal error.");
            } else {
                
                long svc = 0;
                for (long c = 0; c < channelcount; c++, svc = (svc < numstartvalues - 1 ? svc + 1 : svc)) {
                    float temp = (svc < numstartvalues ? startvalues[svc] : 0.);
                    dest_sample[0 * channelcount + c] = temp;
                    for (long f = 0; f < framecount; f++) {
                        dest_sample[(f+1) * channelcount + c] = dest_sample[f * channelcount + c] + orig_sample_wk[f * channelcount + c];
                    }
                }
                
            }
            
            buffer_setdirty(dest);
            ears_buffer_unlocksamples(dest);
        }
        
        if (source == dest) { // inplace operation!
            if (orig_sample_wk)
                bach_freeptr(orig_sample_wk);
        } else {
            ears_buffer_unlocksamples(source);
        }
    }
    
    return err;
}

t_ears_err ears_buffer_fromdiffs(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, t_buffer_obj *initial)
{
    if (!initial)
        return ears_buffer_fromdiffs(ob, source, dest, NULL, 0);
    
    float *sample = ears_buffer_locksamples(initial);
    if (!sample) {
        return ears_buffer_fromdiffs(ob, source, dest, NULL, 0);
    } else {
        long numchans = ears_buffer_get_numchannels(ob, initial);
        long numsamps = ears_buffer_get_size_samps(ob, initial);
        float *initial_fl = NULL;
        if (numchans > 0 && numsamps >= 1) {
            initial_fl = (float *)bach_newptrclear(numchans * sizeof(float));
            for (long c = 0; c < numchans; c++)
                initial_fl[c] = sample[0 * numchans + c];
        }
        ears_buffer_unlocksamples(initial);
        return ears_buffer_fromdiffs(ob, source, dest, initial_fl, initial_fl ? numchans : 0);
    }
}

t_ears_err ears_buffer_phasewrap(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, e_ears_angleunit angleunit)
{
    if (!source || !dest)
        return EARS_ERR_NO_BUFFER;

    
    t_ears_err err = EARS_ERR_NONE;
    float *orig_sample = ears_buffer_locksamples(source);
    
    if (!orig_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        t_atom_long    channelcount = buffer_getchannelcount(source);        // number of floats in a frame
        t_atom_long    framecount   = buffer_getframecount(source);            // number of floats long the buffer is for a single channel
        
        if (source != dest) { // inplace operation!
            ears_buffer_copy_format(ob, source, dest, true);
            ears_buffer_set_size_and_numchannels(ob, dest, framecount, channelcount);
        }

        float *dest_sample = (source == dest) ? orig_sample : ears_buffer_locksamples(dest);
        
        if (!dest_sample) {
            err = EARS_ERR_CANT_WRITE;
            object_error((t_object *)ob, EARS_ERROR_BUF_CANT_WRITE);
        } else {
            
            if (buffer_getchannelcount(dest) != channelcount ||
                buffer_getframecount(dest) != framecount) {
                object_error(ob, "Internal error.");
            } else {
                
                switch (angleunit) {
                    case EARS_ANGLEUNIT_RADIANS:
                        for (long c = 0; c < channelcount; c++) {
                            for (long f = 0; f < framecount; f++) {
                                dest_sample[f * channelcount + c] = ears_principal_phase(orig_sample[f * channelcount + c]);
                            }
                        }
                        break;

                    default:
                        for (long c = 0; c < channelcount; c++) {
                            for (long f = 0; f < framecount; f++) {
                                dest_sample[f * channelcount + c] = ears_convert_angleunit(ears_principal_phase(ears_convert_angleunit(orig_sample[f * channelcount + c], angleunit, EARS_ANGLEUNIT_RADIANS)), EARS_ANGLEUNIT_RADIANS, angleunit);
                            }
                        }
                        break;
                }
                
            }
            
            buffer_setdirty(dest);
            if (source != dest)
                ears_buffer_unlocksamples(dest);
        }
        
        ears_buffer_unlocksamples(source);
    }
    
    return err;
}




t_ears_err ears_buffer_phaseunwrap(t_object *ob, t_buffer_obj *source, t_buffer_obj *dest, e_ears_angleunit angleunit)
{
    t_ears_err err = EARS_ERR_NONE, this_err = EARS_ERR_NONE;
    t_buffer_obj *temp = ears_buffer_make(NULL);

    if ((this_err = ears_buffer_todiffs(ob, source, temp)) != EARS_ERR_NONE)
        err = this_err;

    if ((this_err = ears_buffer_phasewrap(ob, temp, temp, angleunit)) != EARS_ERR_NONE)
        err = this_err;

    if ((this_err = ears_buffer_fromdiffs(ob, temp, dest, source)) != EARS_ERR_NONE)
        err = this_err;
    
    ears_buffer_free(temp);
    
    return err;
}



t_ears_err ears_buffer_op(t_object *ob, t_buffer_obj *source1, t_buffer_obj *source2, t_buffer_obj *dest, e_ears_op op, e_ears_resamplingpolicy resamplingpolicy, long resamplingfiltersize, e_ears_resamplingmode resamplingmode)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!dest)
        return EARS_ERR_NO_BUFFER;
    
    double sr = ears_buffer_get_sr(ob, source1);
    t_buffer_obj *sources[2];
    sources[0] = source1; sources[1] = source2;

    float *samples[2];
    long num_samples[2];
    bool must_free_samples[2];
    bool resampled;

    samples[0] = ears_buffer_locksamples(sources[0]);
    if (!samples[0]) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        return EARS_ERR_CANT_READ;
    }
    samples[1] = (source1 == source2 ? samples[0] : ears_buffer_locksamples(sources[1]));
    if (!samples[1]) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
        ears_buffer_unlocksamples(sources[0]);
        return EARS_ERR_CANT_READ;
    }
    num_samples[0] = ears_buffer_get_size_samps(ob, sources[0]);
    num_samples[1] = ears_buffer_get_size_samps(ob, sources[1]);
    must_free_samples[0] = must_free_samples[1] = 0;

    ears_buffer_preprocess_sr_policies(ob, sources, 2, resamplingpolicy, resamplingfiltersize, resamplingmode, &sr, &resampled, samples, num_samples, must_free_samples, NULL);
    
    ears_buffer_set_sr(ob, dest, sr);
    
    long numchans1 = ears_buffer_get_numchannels(ob, sources[0]);
    long numchans2 = ears_buffer_get_numchannels(ob, sources[1]);
    long numsamps1 = num_samples[0];
    long numsamps2 = num_samples[1];

    long outnumchans = MIN(numchans1, numchans2);
    long outnumsamps = MIN(numsamps1, numsamps2);

    ears_buffer_set_size_and_numchannels(ob, dest, outnumsamps, outnumchans);

    float *dest_sample = ((dest == sources[0] && !must_free_samples[0]) ? samples[0] : (dest == sources[1] && !must_free_samples[1] ? samples[1] : ears_buffer_locksamples(dest)));
    if (!dest_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        outnumchans = MIN(outnumchans, ears_buffer_get_numchannels(ob, dest));
        outnumsamps = MIN(outnumsamps, ears_buffer_get_size_samps(ob, dest));
        
        switch (op) {
            case EARS_OP_TIMES:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[0][f*outnumchans + c] * samples[1][f*outnumchans + c];
                    }
                }
                break;
                
            case EARS_OP_PLUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[0][f*outnumchans + c] + samples[1][f*outnumchans + c];
                    }
                }
                break;
                
            case EARS_OP_MINUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[0][f*outnumchans + c] - samples[1][f*outnumchans + c];
                    }
                }
                break;
                
            case EARS_OP_DIV:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[0][f*outnumchans + c] / samples[1][f*outnumchans + c];
                    }
                }
                break;
                
            case EARS_OP_RMINUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[1][f*outnumchans + c] - samples[0][f*outnumchans + c];
                    }
                }
                break;
                
            case EARS_OP_RDIV:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = samples[1][f*outnumchans + c] / samples[0][f*outnumchans + c];
                    }
                }
                break;

            default:
                break;
        }
    }

    if (dest != sources[0] && !must_free_samples[0])
        ears_buffer_unlocksamples(dest);
    
    if (must_free_samples[0])
        bach_freeptr(samples[0]);
    else
        ears_buffer_unlocksamples(sources[0]);
    
    if (must_free_samples[1])
        bach_freeptr(samples[1]);
    else if (source1 != source2 && source1 != dest)
        ears_buffer_unlocksamples(sources[1]);

    return err;
}




t_ears_err ears_buffer_number_op(t_object *ob, t_buffer_obj *source, double num, t_buffer_obj *dest, e_ears_op op)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!dest)
        return EARS_ERR_NO_BUFFER;
    
    float *sample = ears_buffer_locksamples(source);
    if (!sample) {
        object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    float *dest_sample = NULL;
    if (dest == source) {
        dest_sample = sample;
    } else {
        ears_buffer_copy_format(ob, source, dest, true);
        ears_buffer_set_size_and_numchannels(ob, dest, buffer_getframecount(source), buffer_getchannelcount(source));
        dest_sample = ears_buffer_locksamples(dest);
    }
    
    if (!dest_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        long outnumchans = buffer_getchannelcount(dest);
        long outnumsamps = buffer_getframecount(dest);
        
        switch (op) {
            case EARS_OP_TIMES:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] * num;
                    }
                }
                break;
                
            case EARS_OP_PLUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] + num;
                    }
                }
                break;
                
            case EARS_OP_MINUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] - num;
                    }
                }
                break;
                
            case EARS_OP_DIV:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] / num;
                    }
                }
                break;
                
            case EARS_OP_RMINUS:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] - num;
                    }
                }
                break;
                
            case EARS_OP_RDIV:
                for (long c = 0; c < outnumchans; c++) {
                    for (long f = 0; f < outnumsamps; f++) {
                        dest_sample[f*outnumchans + c] = sample[f*outnumchans + c] / num;
                    }
                }
                break;

            default:
                break;
        }
    }

    if (dest != source)
        ears_buffer_unlocksamples(dest);
    ears_buffer_unlocksamples(source);

    return err;
}



t_ears_err ears_buffer_envelope_op(t_object *ob, t_buffer_obj *source, t_llll *env, t_buffer_obj *dest, e_ears_op op, e_slope_mapping slopemapping)
{
    t_ears_err err = EARS_ERR_NONE;
    
    if (!dest)
        return EARS_ERR_NO_BUFFER;
    
    float *sample = ears_buffer_locksamples(source);
    if (!sample) {
        object_error(ob, EARS_ERROR_BUF_NO_BUFFER);
        return EARS_ERR_NO_BUFFER;
    }
    
    float *dest_sample = NULL;
    if (dest == source) {
        dest_sample = sample;
    } else {
        ears_buffer_copy_format(ob, source, dest, true);
        ears_buffer_set_size_and_numchannels(ob, dest, buffer_getframecount(source), buffer_getchannelcount(source));
        dest_sample = ears_buffer_locksamples(dest);
    }
    
    if (!dest_sample) {
        err = EARS_ERR_CANT_READ;
        object_error((t_object *)ob, EARS_ERROR_BUF_CANT_READ);
    } else {
        long channelcount = buffer_getchannelcount(dest);
        long framecount = buffer_getframecount(dest);
        
        t_ears_envelope_iterator eei = ears_envelope_iterator_create(env, 0., false, slopemapping);
        
        switch (op) {
            case EARS_OP_TIMES:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] * num;
                    }
                }
                break;
                
            case EARS_OP_PLUS:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] + num;
                    }
                }
                break;
                
            case EARS_OP_MINUS:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] - num;
                    }
                }
                break;
                
            case EARS_OP_DIV:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] / num;
                    }
                }
                break;
                
            case EARS_OP_RMINUS:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] - num;
                    }
                }
                break;
                
            case EARS_OP_RDIV:
                for (long f = 0; f < framecount; f++) {
                    double num = ears_envelope_iterator_walk_interp(&eei, f, framecount);
                    for (long c = 0; c < channelcount; c++) {
                        dest_sample[f*channelcount + c] = sample[f*channelcount + c] / num;
                    }
                }
                break;

            default:
                break;
        }
    }

    if (dest != source)
        ears_buffer_unlocksamples(dest);
    ears_buffer_unlocksamples(source);

    return err;
}
